<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>HoraeDB 文档</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">简介</li><li class="chapter-item "><a href="about.html"><strong aria-hidden="true">1.</strong> 什么是 HoraeDB</a></li><li class="chapter-item "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> 快速开始</a></li><li class="chapter-item affix "><li class="part-title">用户手册</li><li class="chapter-item "><a href="sql/README.html"><strong aria-hidden="true">3.</strong> SQL 语法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/model/README.html"><strong aria-hidden="true">3.1.</strong> 数据模型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/model/data_types.html"><strong aria-hidden="true">3.1.1.</strong> 数据类型</a></li><li class="chapter-item "><a href="sql/model/special_columns.html"><strong aria-hidden="true">3.1.2.</strong> 特殊字段</a></li></ol></li><li class="chapter-item "><a href="sql/identifier.html"><strong aria-hidden="true">3.2.</strong> 标识符</a></li><li class="chapter-item "><a href="sql/ddl/README.html"><strong aria-hidden="true">3.3.</strong> 表结构操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/ddl/create_table.html"><strong aria-hidden="true">3.3.1.</strong> 建表</a></li><li class="chapter-item "><a href="sql/ddl/alter_table.html"><strong aria-hidden="true">3.3.2.</strong> 表结构变更</a></li><li class="chapter-item "><a href="sql/ddl/drop_table.html"><strong aria-hidden="true">3.3.3.</strong> 删除表</a></li></ol></li><li class="chapter-item "><a href="sql/dml/README.html"><strong aria-hidden="true">3.4.</strong> 数据操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/dml/insert.html"><strong aria-hidden="true">3.4.1.</strong> 数据写入</a></li><li class="chapter-item "><a href="sql/dml/select.html"><strong aria-hidden="true">3.4.2.</strong> 数据查询</a></li></ol></li><li class="chapter-item "><a href="sql/engine_options.html"><strong aria-hidden="true">3.5.</strong> 引擎配置</a></li><li class="chapter-item "><a href="sql/utility.html"><strong aria-hidden="true">3.6.</strong> 常见 SQL</a></li><li class="chapter-item "><a href="sql/functions/scalar_functions.html"><strong aria-hidden="true">3.7.</strong> 标量函数</a></li><li class="chapter-item "><a href="sql/functions/aggregate_functions.html"><strong aria-hidden="true">3.8.</strong> 聚合函数</a></li></ol></li><li class="chapter-item "><a href="cluster_deployment/README.html"><strong aria-hidden="true">4.</strong> 集群部署</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cluster_deployment/platform.html"><strong aria-hidden="true">4.1.</strong> 支持平台</a></li><li class="chapter-item "><a href="cluster_deployment/no_meta.html"><strong aria-hidden="true">4.2.</strong> NoMeta 模式</a></li><li class="chapter-item "><a href="cluster_deployment/with_meta.html"><strong aria-hidden="true">4.3.</strong> WithMeta 模式</a></li></ol></li><li class="chapter-item "><a href="sdk/README.html"><strong aria-hidden="true">5.</strong> SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/java.html"><strong aria-hidden="true">5.1.</strong> Java SDK</a></li><li class="chapter-item "><a href="sdk/go.html"><strong aria-hidden="true">5.2.</strong> Go SDK</a></li><li class="chapter-item "><a href="sdk/python.html"><strong aria-hidden="true">5.3.</strong> Python SDK</a></li><li class="chapter-item "><a href="sdk/rust.html"><strong aria-hidden="true">5.4.</strong> Rust SDK</a></li></ol></li><li class="chapter-item "><a href="operation/README.html"><strong aria-hidden="true">6.</strong> 运维</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="operation/table.html"><strong aria-hidden="true">6.1.</strong> 表</a></li><li class="chapter-item "><a href="operation/system_table.html"><strong aria-hidden="true">6.2.</strong> 系统表</a></li><li class="chapter-item "><a href="operation/block_list.html"><strong aria-hidden="true">6.3.</strong> 黑名单</a></li><li class="chapter-item "><a href="operation/observability.html"><strong aria-hidden="true">6.4.</strong> 监控</a></li><li class="chapter-item "><a href="operation/horaemeta.html"><strong aria-hidden="true">6.5.</strong> HoraeMeta</a></li></ol></li><li class="chapter-item "><a href="ecosystem/README.html"><strong aria-hidden="true">7.</strong> 周边生态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ecosystem/prometheus.html"><strong aria-hidden="true">7.1.</strong> Prometheus</a></li><li class="chapter-item "><a href="ecosystem/influxdb.html"><strong aria-hidden="true">7.2.</strong> InfluxDB</a></li><li class="chapter-item "><a href="ecosystem/opentsdb.html"><strong aria-hidden="true">7.3.</strong> OpenTSDB</a></li></ol></li><li class="chapter-item "><li class="part-title">开发者手册</li><li class="chapter-item "><a href="dev/platform.html"><strong aria-hidden="true">8.</strong> 支持平台</a></li><li class="chapter-item "><a href="dev/compile_run.html"><strong aria-hidden="true">9.</strong> 编译运行</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/profiling.html"><strong aria-hidden="true">9.1.</strong> 剖析</a></li></ol></li><li class="chapter-item "><a href="dev/conventional_commit.html"><strong aria-hidden="true">10.</strong> 开发规约</a></li><li class="chapter-item "><a href="dev/style_guide.html"><strong aria-hidden="true">11.</strong> 风格规范</a></li><li class="chapter-item "><a href="dev/roadmap.html"><strong aria-hidden="true">12.</strong> 里程碑</a></li><li class="chapter-item affix "><li class="part-title">技术系列文章</li><li class="chapter-item "><a href="design/architecture.html"><strong aria-hidden="true">13.</strong> 整体架构</a></li><li class="chapter-item "><a href="design/clustering.html"><strong aria-hidden="true">14.</strong> 集群</a></li><li class="chapter-item "><a href="design/shared_nothing.html"><strong aria-hidden="true">15.</strong> Shared-Nothing</a></li><li class="chapter-item "><a href="design/storage.html"><strong aria-hidden="true">16.</strong> 存储</a></li><li class="chapter-item "><a href="design/wal.html"><strong aria-hidden="true">17.</strong> WAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design/wal_on_rocksdb.html"><strong aria-hidden="true">17.1.</strong> WAL on RocksDB</a></li><li class="chapter-item "><a href="design/wal_on_kafka.html"><strong aria-hidden="true">17.2.</strong> WAL on Kafka</a></li></ol></li><li class="chapter-item "><a href="design/table_partitioning.html"><strong aria-hidden="true">18.</strong> 分区表</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">HoraeDB 文档</h1>

                    <div class="right-buttons">

                        <button id="lang-toggle" class="icon-button" type="button" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list" >
<!--                             <i class="fa fa-globe"></i> -->
                    <i>
                        <svg t="1675840511805" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2677" width="16" height="16"><path d="M511.573333 85.333333C276.053333 85.333333 85.333333 276.48 85.333333 512s190.72 426.666667 426.24 426.666667C747.52 938.666667 938.666667 747.52 938.666667 512S747.52 85.333333 511.573333 85.333333z m295.68 256h-125.866666a667.733333 667.733333 0 0 0-58.88-151.893333A342.613333 342.613333 0 0 1 807.253333 341.333333zM512 172.373333c35.413333 51.2 63.146667 107.946667 81.493333 168.96h-162.986666c18.346667-61.013333 46.08-117.76 81.493333-168.96zM181.76 597.333333C174.933333 570.026667 170.666667 541.44 170.666667 512s4.266667-58.026667 11.093333-85.333333h144.213333c-3.413333 28.16-5.973333 56.32-5.973333 85.333333 0 29.013333 2.56 57.173333 5.973333 85.333333H181.76z m34.986667 85.333334h125.866666c13.653333 53.333333 33.28 104.533333 58.88 151.893333A340.778667 340.778667 0 0 1 216.746667 682.666667z m125.866666-341.333334H216.746667a340.778667 340.778667 0 0 1 184.746666-151.893333A667.733333 667.733333 0 0 0 342.613333 341.333333zM512 851.626667c-35.413333-51.2-63.146667-107.946667-81.493333-168.96h162.986666c-18.346667 61.013333-46.08 117.76-81.493333 168.96zM611.84 597.333333H412.16c-3.84-28.16-6.826667-56.32-6.826667-85.333333 0-29.013333 2.986667-57.6 6.826667-85.333333h199.68c3.84 27.733333 6.826667 56.32 6.826667 85.333333 0 29.013333-2.986667 57.173333-6.826667 85.333333z m10.666667 237.226667c25.6-47.36 45.226667-98.56 58.88-151.893333h125.866666a342.613333 342.613333 0 0 1-184.746666 151.893333zM698.026667 597.333333c3.413333-28.16 5.973333-56.32 5.973333-85.333333 0-29.013333-2.56-57.173333-5.973333-85.333333h144.213333c6.826667 27.306667 11.093333 55.893333 11.093333 85.333333s-4.266667 58.026667-11.093333 85.333333h-144.213333z" fill="#000000" fill-opacity=".87" p-id="2678"></path></svg>
                        <a id="lang_comment"></a>
                    </i>

                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="en">English</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="cn">中文</button></li>
                        </ul>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/apache/incubator-horaedb" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <script>
                window.onload = function(){
                    var path_lang = window.location.pathname.split('/')[1];
                    document.getElementById('lang_comment').innerHTML = path_lang=='cn'?"Language":"语言";
                };
                </script>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <p><img src="https://github.com/apache/incubator-horaedb/raw/main/docs/logo/horaedb-banner-white-small.jpg" alt="HoraeDB" /></p>
<p><img src="https://img.shields.io/badge/license-Apache--2.0-green.svg" alt="License" />
<a href="https://github.com/apache/incubator-horaedb/actions/workflows/ci.yml"><img src="https://github.com/apache/incubator-horaedb/actions/workflows/ci.yml/badge.svg" alt="CI" /></a>
<a href="https://github.com/apache/incubator-horaedb/issues"><img src="https://img.shields.io/github/issues/apachge/incubator-horaedb" alt="OpenIssue" /></a></p>
<p>Apache HoraeDB™ (incubating) 是一款高性能、分布式的云原生时序数据库。</p>
<h1 id="愿景"><a class="header" href="#愿景">愿景</a></h1>
<p>在经典的时序数据库中，<code>Tag</code> 列（InfluxDB 称为 <code>Tag</code>，Prometheus 称为 <code>Label</code>）通常使用倒排来进行索引。
我们发现在不同的情况下，<code>Tag</code> 的基数差异很大。在某些情况下，<code>Tag</code> 的基数非常高，存储和检索倒排索引的成本非常高。
同时，我们发现分析型数据库经常使用的扫描+剪枝可以很好地处理这些场景。</p>
<p>HoraeDB 的基础设计思想是采用混合存储格式和相应的查询方法，以便在处理时序和分析场景时都获得更好的性能。</p>
<h1 id="如何使用-horaedb"><a class="header" href="#如何使用-horaedb">如何使用 HoraeDB？</a></h1>
<ul>
<li>查看 <a href="quick_start.html">快速开始</a> 掌握快速使用 HoraeDB 的方式</li>
<li>HoraeDB 支持的数据模型请查看 <a href="sql/model/README.html">Data Model</a></li>
<li>SQL 使用相关请查看 <a href="sql/README.html">SQL</a></li>
<li>HoraeDB 支持的相关 SDK 请查看 <a href="sdk/README.html">SDK</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>本章介绍如何快速启动 HoraeDB。在这里你将会学到启动一个单机模式的 HoraeDB，然后使用 SQL 写入一些数据并查询结果。</p>
<h2 id="启动"><a class="header" href="#启动">启动</a></h2>
<p>使用 <a href="https://github.com/apache/incubator-horaedb/pkgs/container/horaedb-server">HoraeDB docker 镜像</a> 是一种最简单的启动方式；如果你还没有安装 Docker，请首先参考 <a href="https://www.docker.com/products/docker-desktop/">这里</a> 安装 Docker。</p>
<blockquote>
<p>注意：请选择一个大于等于 v1.0.0 的 tag 镜像。</p>
</blockquote>
<p>使用如下命令安装并启动一个单机版 HoraeDB。</p>
<pre><code class="language-bash">docker run -d --name horaedb-server \
  -p 8831:8831 \
  -p 3307:3307 \
  -p 5440:5440 \
  ghcr.io/apache/horaedb-server:nightly-20231222-f57b3827
</code></pre>
<p>启动后 HoraeDB 会监听如下端口：</p>
<ul>
<li>8831, gRPC port</li>
<li>3307, MySQL port</li>
<li>5440, HTTP port</li>
</ul>
<p><code>HTTP</code> 协议是最简单的交互方式，接下来的演示会使用 <code>HTTP</code> 协议进行介绍。不过在生产环境，我们推荐使用 <code>gRPC/MySQL</code>。</p>
<h3 id="自定义-docker-的配置"><a class="header" href="#自定义-docker-的配置">自定义 docker 的配置</a></h3>
<p>参考如下命令，可以自定义 docker 中 horaedb-server 的配置，并把数据目录 <code>/data</code> 挂载到 docker 母机的硬盘上。</p>
<pre><code>wget -c https://raw.githubusercontent.com/apache/incubator-horaedb/main/docs/minimal.toml -O horaedb.toml

sed -i 's/\/tmp\/horaedb/\/data/g' horaedb.toml

docker run -d --name horaedb-server \
  -p 8831:8831 \
  -p 3307:3307 \
  -p 5440:5440 \
  -v ./horaedb.toml:/etc/horaedb/horaedb.toml \
  -v ./data:/data \
  ghcr.io/apache/horaedb-server:nightly-20231222-f57b3827
</code></pre>
<h2 id="写入和查询数据"><a class="header" href="#写入和查询数据">写入和查询数据</a></h2>
<h3 id="建表"><a class="header" href="#建表">建表</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
-d '
CREATE TABLE `demo` (
    `name` string TAG,
    `value` double NOT NULL,
    `t` timestamp NOT NULL,
    timestamp KEY (t))
ENGINE=Analytic
  with
(enable_ttl=&quot;false&quot;)
'
</code></pre>
<h3 id="写数据"><a class="header" href="#写数据">写数据</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
-d '
INSERT INTO demo (t, name, value)
    VALUES (1651737067000, &quot;horaedb&quot;, 100)
'
</code></pre>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
-d '
SELECT
    *
FROM
    `demo`
'
</code></pre>
<h3 id="展示建表语句"><a class="header" href="#展示建表语句">展示建表语句</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
-d '
SHOW CREATE TABLE `demo`
'
</code></pre>
<h3 id="删除表"><a class="header" href="#删除表">删除表</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
-d '
DROP TABLE `demo`
'
</code></pre>
<h2 id="使用-sdk"><a class="header" href="#使用-sdk">使用 SDK</a></h2>
<p>当前我们支持多种开发语言 SDK，例如 Java，Rust，Python, Go 等, 具体使用方式请参考 <a href="sdk/README.html">sdk</a>。</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>恭喜你，你已经学习了 HoraeDB 的简单使用。关于 HoraeDB 的更多信息，请参见以下内容。</p>
<ul>
<li><a href="sql/README.html">SQL 语法</a></li>
<li><a href="cluster_deployment/README.html">部署文档</a></li>
<li><a href="operation/README.html">运维文档</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-语法"><a class="header" href="#sql-语法">SQL 语法</a></h1>
<p>本章介绍 HoraeDB 的 SQL 使用语法。</p>
<ul>
<li><a href="sql/model/README.html">数据模型</a>
<ul>
<li><a href="sql/model/data_types.html">数据类型</a></li>
<li><a href="sql/model/special_columns.html">特殊字段</a></li>
</ul>
</li>
<li><a href="sql/identifier.html">标识符</a></li>
<li><a href="sql/ddl/README.html">表结构操作</a>
<ul>
<li><a href="sql/ddl/create_table.html">建表</a></li>
<li><a href="sql/ddl/alter_table.html">表结构变更</a></li>
<li><a href="sql/ddl/drop_table.html">删除表</a></li>
</ul>
</li>
<li><a href="sql/dml/README.html">数据操作</a>
<ul>
<li><a href="sql/dml/insert.html">数据写入</a></li>
<li><a href="sql/dml/select.html">数据查询</a></li>
</ul>
</li>
<li><a href="sql/engine_options.html">引擎配置</a></li>
<li><a href="sql/utility.html">常见 SQL</a></li>
<li><a href="sql/functions/scalar_functions.html">标量函数</a></li>
<li><a href="sql/functions/aggregate_functions.html">聚合函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据模型"><a class="header" href="#数据模型">数据模型</a></h1>
<p>本章介绍 HoraeDB 的数据模型。</p>
<ul>
<li><a href="sql/model/data_types.html">数据类型</a></li>
<li><a href="sql/model/special_columns.html">特殊字段</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>HoraeDB 实现了 <code>Table</code> 模型，支持的数据类型和 MySQL 比较类似。
下列表格列出了 HoraeDB 的数据类型和 MySQL 的数据类型的对应关系。</p>
<h2 id="支持的数据类型-大小写不敏感"><a class="header" href="#支持的数据类型-大小写不敏感">支持的数据类型 (大小写不敏感)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>SQL</th><th>HoraeDB</th></tr></thead><tbody>
<tr><td>null</td><td>Null</td></tr>
<tr><td>timestamp</td><td>Timestamp</td></tr>
<tr><td>double</td><td>Double</td></tr>
<tr><td>float</td><td>Float</td></tr>
<tr><td>string</td><td>String</td></tr>
<tr><td>Varbinary</td><td>Varbinary</td></tr>
<tr><td>uint64</td><td>UInt64</td></tr>
<tr><td>uint32</td><td>UInt32</td></tr>
<tr><td>uint16</td><td>UInt16</td></tr>
<tr><td>uint8</td><td>UInt8</td></tr>
<tr><td>int64/bigint</td><td>Int64</td></tr>
<tr><td>int32/int</td><td>Int32</td></tr>
<tr><td>int16/smallint</td><td>Int16</td></tr>
<tr><td>int8/tinyint</td><td>Int8</td></tr>
<tr><td>boolean</td><td>Boolean</td></tr>
<tr><td>date</td><td>Date</td></tr>
<tr><td>time</td><td>Time</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="特殊字段"><a class="header" href="#特殊字段">特殊字段</a></h1>
<p>HoraeDB 的表的约束如下：</p>
<ul>
<li>必须有主键</li>
<li>主键必须包含时间列，并且只能包含一个时间列</li>
<li>主键不可为空，并且主键的组成字段也不可为空</li>
</ul>
<h2 id="timestamp-列"><a class="header" href="#timestamp-列">Timestamp 列</a></h2>
<p>HoraeDB 的表必须包含一个时间戳列，对应时序数据中的时间，例如 OpenTSDB/Prometheus 的 <code>timestamp</code>。
时间戳列通过关键字 <code>timestamp key</code> 设置，例如 <code>TIMESTAMP KEY(ts)</code>。</p>
<h2 id="tag-列"><a class="header" href="#tag-列">Tag 列</a></h2>
<p><code>Tag</code> 关键字定义了一个字段作为标签列，和时序数据中的 <code>tag</code> 类似，例如 OpenTSDB 的 <code>tag</code> 或 Prometheus 的 <code>label</code>。</p>
<h2 id="主键"><a class="header" href="#主键">主键</a></h2>
<p>主键用于数据去重和排序，由一些列和一个时间列组成。
主键可以通过以下一些方式设置：</p>
<ul>
<li>使用 <code>primary key</code> 关键字</li>
<li>使用 <code>tag</code> 来自动生成 TSID，HoraeDB 默认将使用 <code>(TSID,timestamp)</code> 作为主键。</li>
<li>只设置时间戳列，HoraeDB 将使用 <code>(timestamp)</code> 作为主键。</li>
</ul>
<p>注意：如果同时指定了主键和 <code>Tag</code> 列，那么 <code>Tag</code> 列只是一个额外的信息标识，不会影响主键生成逻辑。</p>
<pre><code class="language-sql">CREATE TABLE with_primary_key(
  ts TIMESTAMP NOT NULL,
  c1 STRING NOT NULL,
  c2 STRING NULL,
  c4 STRING NULL,
  c5 STRING NULL,
  TIMESTAMP KEY(ts),
  PRIMARY KEY(c1, ts)
) ENGINE=Analytic WITH (ttl='7d');

CREATE TABLE with_tag(
    ts TIMESTAMP NOT NULL,
    c1 STRING TAG NOT NULL,
    c2 STRING TAG NULL,
    c3 STRING TAG NULL,
    c4 DOUBLE NULL,
    c5 STRING NULL,
    c6 STRING NULL,
    TIMESTAMP KEY(ts)
) ENGINE=Analytic WITH (ttl='7d');

CREATE TABLE with_timestamp(
    ts TIMESTAMP NOT NULL,
    c1 STRING NOT NULL,
    c2 STRING NULL,
    c3 STRING NULL,
    c4 DOUBLE NULL,
    c5 STRING NULL,
    c6 STRING NULL,
    TIMESTAMP KEY(ts)
) ENGINE=Analytic WITH (ttl='7d');
</code></pre>
<h2 id="tsid"><a class="header" href="#tsid">TSID</a></h2>
<p>如果建表时没有设置主键，并且提供了 <code>Tag</code> 列，HoraeDB 会自动生成一个 <code>TSID</code> 列和时间戳列作为主键。<code>TSID</code> 由所有 <code>Tag</code> 列的 hash 值生成，本质上这是一种自动生成 ID 的机制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标识符"><a class="header" href="#标识符">标识符</a></h1>
<p>HoraeDB 中表名、列名等标识符不能是保留关键字或以数字和标点符号开始，不过 HoraeDB 允许用反引号引用标识符（`）。在这种情况下，它可以是任何字符串，如 <code>00_table</code> 或 <code>select</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表结构操作"><a class="header" href="#表结构操作">表结构操作</a></h1>
<p>本章介绍表结构相关 SQL 语句：</p>
<ul>
<li><a href="sql/ddl/create_table.html">建表</a></li>
<li><a href="sql/ddl/alter_table.html">表结构变更</a></li>
<li><a href="sql/ddl/drop_table.html">删除表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建表"><a class="header" href="#创建表">创建表</a></h1>
<h2 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h2>
<p>建表的基础语法如下 ( <code>[]</code> 之间的内容是可选部分):</p>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS]
    table_name ( column_definitions )
    ENGINE = engine_type
    [WITH ( table_options )];
</code></pre>
<p>列定义的语法 :</p>
<pre><code class="language-sql">column_name column_type [[NOT] NULL] {[TAG] | [TIMESTAMP KEY] | [PRIMARY KEY]} [DICTIONARY] [COMMENT '']
</code></pre>
<p>表选项的语法是键-值对，值用单引号（<code>'</code>）来引用。例如：</p>
<pre><code class="language-sql">... WITH ( enable_ttl='false' )
</code></pre>
<h2 id="if-not-exists"><a class="header" href="#if-not-exists">IF NOT EXISTS</a></h2>
<p>添加 <code>IF NOT EXISTS</code> 时，HoraeDB 在表名已经存在时会忽略建表错误。</p>
<h2 id="定义列"><a class="header" href="#定义列">定义列</a></h2>
<p>一个列的定义至少应该包含名称和类型部分，支持的类型见 <a href="sql/ddl/../model/data_types.html">这里</a>。</p>
<p>列默认为可空，即 &quot;NULL &quot; 关键字是隐含的；添加 <code>NOT NULL</code> 时列不可为空。</p>
<pre><code class="language-sql">-- this definition
a_nullable int
-- equals to
a_nullable int NULL

-- add NOT NULL to make it required
b_not_null NOT NULL
</code></pre>
<p>定义列时可以使用相关的关键字将列标记为 <a href="sql/ddl/../model/special_columns.html">特殊列</a>。</p>
<p>对于 string 的 tag 列，推荐设置为字典类型来减少内存占用：</p>
<pre><code class="language-sql">`tag1` string TAG DICTIONARY
</code></pre>
<h2 id="引擎设置"><a class="header" href="#引擎设置">引擎设置</a></h2>
<p>HoraeDB 支持指定某个表使用哪种引擎，目前支持的引擎类型为 <code>Analytic</code>。注意这个属性设置后不可更改。</p>
<h2 id="分区设置"><a class="header" href="#分区设置">分区设置</a></h2>
<blockquote>
<p>仅适用于集群部署模式</p>
</blockquote>
<pre><code>CREATE TABLE ... PARTITION BY KEY
</code></pre>
<p>下面这个例子创建了一个具有 8 个分区的表，分区键为 <code>name</code>：</p>
<pre><code class="language-sql">CREATE TABLE `demo` (
    `name` string TAG COMMENT 'client username',
    `value` double NOT NULL,
    `t` timestamp NOT NULL,
    timestamp KEY (t)
)
    PARTITION BY KEY(name) PARTITIONS 8
    ENGINE=Analytic
    with (
    enable_ttl='false'
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alter-table"><a class="header" href="#alter-table">ALTER TABLE</a></h1>
<p>使用 <code>ALTER TABLE</code> 可以改变表的结构和参数 .</p>
<h2 id="变更表结构"><a class="header" href="#变更表结构">变更表结构</a></h2>
<p>例如可以使用 <code>ADD COLUMN</code> 增加表的列 :</p>
<pre><code class="language-sql">-- create a table and add a column to it
CREATE TABLE `t`(a int, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;
ALTER TABLE `t` ADD COLUMN (b string);
</code></pre>
<p>变更后的表结构如下：</p>
<pre><code>-- DESCRIBE TABLE `t`;

name    type        is_primary  is_nullable is_tag

t       timestamp   true        false       false
tsid    uint64      true        false       false
a       int         false       true        false
b       string      false       true        false
</code></pre>
<h2 id="变更表参数"><a class="header" href="#变更表参数">变更表参数</a></h2>
<p>例如可以使用 <code>MODIFY SETTING</code> 修改表的参数 :</p>
<pre><code class="language-sql">-- create a table and add a column to it
CREATE TABLE `t`(a int, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;
ALTER TABLE `t` MODIFY SETTING write_buffer_size='300M';
</code></pre>
<p>上面的 SQL 用来更改 <code>writer_buffer</code> 大小，变更后的建表如下：</p>
<pre><code class="language-sql">CREATE TABLE `t` (`tsid` uint64 NOT NULL, `t` timestamp NOT NULL, `a` int, PRIMARY KEY(tsid,t), TIMESTAMP KEY(t)) ENGINE=Analytic WITH(arena_block_size='2097152', compaction_strategy='default', compression='ZSTD', enable_ttl='true', num_rows_per_row_group='8192', segment_duration='', storage_format='AUTO', ttl='7d', update_mode='OVERWRITE', write_buffer_size='314572800')
</code></pre>
<p>除此之外，我们可以修改其 <code>ttl</code> 为 10 天：</p>
<pre><code class="language-sql">ALTER TABLE `t` MODIFY SETTING ttl='10d';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-table"><a class="header" href="#drop-table">DROP TABLE</a></h1>
<h2 id="基础语法-1"><a class="header" href="#基础语法-1">基础语法</a></h2>
<p>删除表的基础语法如下:</p>
<pre><code class="language-sql">DROP TABLE [IF EXISTS] table_name
</code></pre>
<p><code>Drop Table</code> 用来删除一个表，请谨慎使用这个语句，因为会同时删除表的定义和表的数据，并且无法恢复。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据操作"><a class="header" href="#数据操作">数据操作</a></h1>
<p>本章介绍数据操作相关的 SQL.</p>
<ul>
<li><a href="sql/dml/./insert.html">数据写入</a></li>
<li><a href="sql/dml/./select.html">数据查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insert"><a class="header" href="#insert">INSERT</a></h1>
<h2 id="基础语法-2"><a class="header" href="#基础语法-2">基础语法</a></h2>
<p>写入数据的基础语法如下：</p>
<pre><code class="language-sql">INSERT [INTO] tbl_name
    [(col_name [, col_name] ...)]
    { {VALUES | VALUE} (value_list) [, (value_list)] ... }
</code></pre>
<p>写入一行数据的示例如下：</p>
<pre><code class="language-sql">INSERT INTO demo(`timestamp`, tag1) VALUES(1667374200022, 'horaedb')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">SELECT</a></h1>
<h2 id="基础语法-3"><a class="header" href="#基础语法-3">基础语法</a></h2>
<p>数据查询的基础语法如下：</p>
<pre><code class="language-sql">SELECT select_expr [, select_expr] ...
    FROM table_name
    [WHERE where_condition]
    [GROUP BY {col_name | expr} ... ]
    [ORDER BY {col_name | expr}
    [ASC | DESC]
    [LIMIT [offset,] row_count ]
</code></pre>
<p>数据查询的语法和 mysql 类似，示例如下：</p>
<pre><code class="language-sql">SELECT * FROM `demo` WHERE time_stamp &gt; '2022-10-11 00:00:00' AND time_stamp &lt; '2022-10-12 00:00:00' LIMIT 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置项"><a class="header" href="#配置项">配置项</a></h1>
<p>建表时可以使用下列的选项配置引擎：</p>
<ul>
<li>
<p><code>enable_ttl</code>：布尔类型，默认为 <code>true</code>，当一个表配置 TTL 时，早于 <code>ttl</code> 的数据不会被查询到并且会被删除。</p>
</li>
<li>
<p><code>ttl</code>：<code>duration</code> 类型，默认值为<code>7d</code>，此项定义数据的生命周期，只在 <code>enable_ttl</code> 为 <code>true</code> 的情况下使用。</p>
</li>
<li>
<p><code>storage_format</code>： <code>string</code> 类型，数据存储的格式，有两种可选:</p>
<ul>
<li><code>columnar</code>, 默认值</li>
<li><code>hybrid</code>, 注意：此功能仍在开发中，将来可能会发生变化。</li>
</ul>
</li>
</ul>
<p>上述两种存储格式详见 <a href="sql/engine_options.html#%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F">存储格式</a> 部分。</p>
<h2 id="存储格式"><a class="header" href="#存储格式">存储格式</a></h2>
<p>HoraeDB 支持两种存储格式，一个是 <code>columnar</code>, 这是传统的列式格式，一个物理列中存储表的一个列。</p>
<pre><code class="language-plaintext">| Timestamp | Device ID | Status Code | Tag 1 | Tag 2 |
| --------- |---------- | ----------- | ----- | ----- |
| 12:01     | A         | 0           | v1    | v1    |
| 12:01     | B         | 0           | v2    | v2    |
| 12:02     | A         | 0           | v1    | v1    |
| 12:02     | B         | 1           | v2    | v2    |
| 12:03     | A         | 0           | v1    | v1    |
| 12:03     | B         | 0           | v2    | v2    |
| .....     |           |             |       |       |
</code></pre>
<p>另一个是 <code>hybrid</code>, 当前还在实验阶段的存储格式，用于在列式存储中模拟面向行的存储，以加速经典的时序查询。</p>
<p>在经典的时序场景中，如 IoT 或 DevOps，查询通常会先按系列 ID（或设备 ID）分组，然后再按时间戳分组。
为了在这些场景中实现良好的性能，数据的物理布局应该与这种风格相匹配， <code>hybrid</code> 格式就是这样提出的。</p>
<pre><code class="language-plaintext"> | Device ID | Timestamp           | Status Code | Tag 1 | Tag 2 | minTime | maxTime |
 |-----------|---------------------|-------------|-------|-------|---------|---------|
 | A         | [12:01,12:02,12:03] | [0,0,0]     | v1    | v1    | 12:01   | 12:03   |
 | B         | [12:01,12:02,12:03] | [0,1,0]     | v2    | v2    | 12:01   | 12:03   |
 | ...       |                     |             |       |       |         |         |
</code></pre>
<ul>
<li>在一个文件中，同一个主键（例如设备 ID）的数据会被压缩到一行。</li>
<li>除了主键之外的列被分成两类：
<ul>
<li><code>collapsible</code>, 这些列会被压缩成一个 list，常用于时序表中的<code>field</code>字段。
<ul>
<li>注意: 当前仅支持定长的字段</li>
</ul>
</li>
<li><code>non-collapsible</code>, 这些列只能包含一个去重值，常用于时序表中的<code>tag</code>字段。
<ul>
<li>注意: 当前仅支持字符串类型</li>
</ul>
</li>
</ul>
</li>
<li>另外多加了两个字段，<code>minTime</code> 和 <code>maxTime</code>， 用于查询中过滤不必要的数据。
<ul>
<li>注意: 暂未实现此能力</li>
</ul>
</li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<pre><code class="language-sql">CREATE TABLE `device` (
    `ts` timestamp NOT NULL,
    `tag1` string tag,
    `tag2` string tag,
    `value1` double,
    `value2` int,
    timestamp KEY (ts)) ENGINE=Analytic
  with (
    enable_ttl = 'false',
    storage_format = 'hybrid'
);
</code></pre>
<p>这段语句会创建一个混合存储格式的表, 这种情况下用户可以通过 <a href="https://formulae.brew.sh/formula/parquet-tools">parquet-tools</a>查看数据格式.
上面定义的表的 parquet 结构如下所示：</p>
<pre><code>message arrow_schema {
  optional group ts (LIST) {
    repeated group list {
      optional int64 item (TIMESTAMP(MILLIS,false));
    }
  }
  required int64 tsid (INTEGER(64,false));
  optional binary tag1 (STRING);
  optional binary tag2 (STRING);
  optional group value1 (LIST) {
    repeated group list {
      optional double item;
    }
  }
  optional group value2 (LIST) {
    repeated group list {
      optional int32 item;
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用-sql"><a class="header" href="#常用-sql">常用 SQL</a></h1>
<p>HoraeDB 中有许多实用的 SQL 工具，可以辅助表操作或查询检查。</p>
<h2 id="查看建表语句"><a class="header" href="#查看建表语句">查看建表语句</a></h2>
<pre><code class="language-sql">SHOW CREATE TABLE table_name;
</code></pre>
<p><code>SHOW CREATE TABLE</code> 返回指定表的当前版本的创建语句，包括列定义、表引擎和参数选项等。例如：</p>
<pre><code class="language-sql">-- create one table
CREATE TABLE `t` (a bigint, b int default 3, c string default 'x', d smallint null, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;
-- Result: affected_rows: 0

-- show how one table should be created.
SHOW CREATE TABLE `t`;

-- Result DDL:
CREATE TABLE `t` (
    `t` timestamp NOT NULL,
    `tsid` uint64 NOT NULL,
    `a` bigint,
    `b` int,
    `c` string,
    `d` smallint,
    PRIMARY KEY(t,tsid),
    TIMESTAMP KEY(t)
) ENGINE=Analytic WITH (
    arena_block_size='2097152',
    compaction_strategy='default',
    compression='ZSTD',
    enable_ttl='true',
    num_rows_per_row_group='8192',
    segment_duration='',
    ttl='7d',
    update_mode='OVERWRITE',
    write_buffer_size='33554432'
)
</code></pre>
<h2 id="查看表信息"><a class="header" href="#查看表信息">查看表信息</a></h2>
<pre><code class="language-sql">DESCRIBE table_name;
</code></pre>
<p><code>DESCRIBE</code> 语句返回一个表的详细结构信息，包括每个字段的名称和类型，字段是否为 <code>Tag</code> 或主键，字段是否可空等。
此外，自动生成的字段 <code>tsid</code> 也会展示在结果里。</p>
<p>例如：</p>
<pre><code class="language-sql">CREATE TABLE `t`(a int, b string, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;

DESCRIBE TABLE `t`;
</code></pre>
<p>返回结果如下：</p>
<pre><code>name    type        is_primary  is_nullable is_tag

t       timestamp   true        false       false
tsid    uint64      true        false       false
a       int         false       true        false
b       string      false       true        false
</code></pre>
<h2 id="解释执行计划"><a class="header" href="#解释执行计划">解释执行计划</a></h2>
<pre><code class="language-sql">EXPLAIN query;
</code></pre>
<p><code>EXPLAIN</code> 语句结果展示一个查询如何被执行。例如：</p>
<pre><code class="language-sql">EXPLAIN SELECT max(value) AS c1, avg(value) AS c2 FROM `t` GROUP BY name;
</code></pre>
<p>结果如下：</p>
<pre><code>logical_plan
Projection: #MAX(07_optimizer_t.value) AS c1, #AVG(07_optimizer_t.value) AS c2
  Aggregate: groupBy=[[#07_optimizer_t.name]], aggr=[[MAX(#07_optimizer_t.value), AVG(#07_optimizer_t.value)]]
    TableScan: 07_optimizer_t projection=Some([name, value])

physical_plan
ProjectionExec: expr=[MAX(07_optimizer_t.value)@1 as c1, AVG(07_optimizer_t.value)@2 as c2]
  AggregateExec: mode=FinalPartitioned, gby=[name@0 as name], aggr=[MAX(07_optimizer_t.value), AVG(07_optimizer_t.value)]
    CoalesceBatchesExec: target_batch_size=4096
      RepartitionExec: partitioning=Hash([Column { name: \&quot;name\&quot;, index: 0 }], 6)
        AggregateExec: mode=Partial, gby=[name@0 as name], aggr=[MAX(07_optimizer_t.value), AVG(07_optimizer_t.value)]
          ScanTable: table=07_optimizer_t, parallelism=8, order=None
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标量函数"><a class="header" href="#标量函数">标量函数</a></h1>
<p>HoraeDB SQL 基于 <a href="https://github.com/CeresDB/arrow-datafusion">DataFusion</a> 实现，支持的标量函数如下。更多详情请参考： <a href="https://github.com/CeresDB/arrow-datafusion/blob/master/docs/source/user-guide/sql/scalar_functions.md">Datafusion</a></p>
<h2 id="数值函数"><a class="header" href="#数值函数">数值函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>abs(x)</td><td>绝对值</td></tr>
<tr><td>acos(x)</td><td>反余弦</td></tr>
<tr><td>asin(x)</td><td>反正弦</td></tr>
<tr><td>atan(x)</td><td>反正切</td></tr>
<tr><td>atan2(y, x)</td><td>y/x 的反正切</td></tr>
<tr><td>ceil(x)</td><td>小于或等于参数的最接近整数</td></tr>
<tr><td>cos(x)</td><td>余弦</td></tr>
<tr><td>exp(x)</td><td>指数</td></tr>
<tr><td>floor(x)</td><td>大于或等于参数的最接近整数</td></tr>
<tr><td>ln(x)</td><td>自然对数</td></tr>
<tr><td>log10(x)</td><td>以 10 为底的对数</td></tr>
<tr><td>log2(x)</td><td>以 2 为底的对数</td></tr>
<tr><td>power(base, exponent)</td><td>幂函数</td></tr>
<tr><td>round(x)</td><td>四舍五入</td></tr>
<tr><td>signum(x)</td><td>根据参数的正负返回 -1、0、+1</td></tr>
<tr><td>sin(x)</td><td>正弦</td></tr>
<tr><td>sqrt(x)</td><td>平方根</td></tr>
<tr><td>tan(x)</td><td>正切</td></tr>
<tr><td>trunc(x)</td><td>截断计算，取整（向零取整）</td></tr>
</tbody></table>
</div>
<h2 id="条件函数"><a class="header" href="#条件函数">条件函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>coalesce</td><td>如果它的参数中有一个不为 null，则返回第一个参数，如果所有参数均为 null，则返回 null。当从数据库中检索数据用于显示时，它经常用于用默认值替换 null 值。</td></tr>
<tr><td>nullif</td><td>如果 value1 等于 value2，则返回 null 值；否则返回 value1。这可用于执行与 coalesce 表达式相反的操作</td></tr>
</tbody></table>
</div>
<h2 id="字符函数"><a class="header" href="#字符函数">字符函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>ascii</td><td>返回参数的第一个字符的 ascii 数字编码。在 UTF8 编码下，返回字符的 Unicode 码点。在其他多字节编码中，参数必须是 ASCII 字符。</td></tr>
<tr><td>bit_length</td><td>返回字符串的比特位数。</td></tr>
<tr><td>btrim</td><td>从字符串的开头和结尾删除给定字符串中的字符组成的最长字符串</td></tr>
<tr><td>char_length</td><td>等效于 length。</td></tr>
<tr><td>character_length</td><td>等效于 length。</td></tr>
<tr><td>concat</td><td>将两个或多个字符串合并为一个字符串。</td></tr>
<tr><td>concat_ws</td><td>使用给定的分隔符组合两个值。</td></tr>
<tr><td>chr</td><td>根据数字码返回字符。</td></tr>
<tr><td>initcap</td><td>将字符串中每个单词的首字母大写。</td></tr>
<tr><td>left</td><td>返回字符串的指定最左边字符。</td></tr>
<tr><td>length</td><td>返回字符串中字符的数量。</td></tr>
<tr><td>lower</td><td>将字符串中的所有字符转换为它们的小写。</td></tr>
<tr><td>lpad</td><td>使用特定字符集将字符串左填充到给定长度。</td></tr>
<tr><td>ltrim</td><td>从字符串的开头删除由字符中的字符组成的最长字符串（默认为空格）。</td></tr>
<tr><td>md5</td><td>计算给定字符串的 MD5 散列值。</td></tr>
<tr><td>octet_length</td><td>等效于 length。</td></tr>
<tr><td>repeat</td><td>返回一个由输入字符串重复指定次数组成的字符串。</td></tr>
<tr><td>replace</td><td>替换字符串中所有子字符串的出现为新子字符串。</td></tr>
<tr><td>reverse</td><td>反转字符串。</td></tr>
<tr><td>right</td><td>返回字符串的指定最右边字符。</td></tr>
<tr><td>rpad</td><td>使用特定字符集将字符串右填充到给定长度。</td></tr>
<tr><td>rtrim</td><td>从字符串的结尾删除包含 characters 中任何字符的最长字符串。</td></tr>
<tr><td>digest</td><td>计算给定字符串的散列值。</td></tr>
<tr><td>split_part</td><td>按指定分隔符拆分字符串，并从结果数组中返回</td></tr>
<tr><td>starts_with</td><td>检查字符串是否以给定字符串开始</td></tr>
<tr><td>strpos</td><td>搜索字符串是否包含一个给定的字符串，并返回位置</td></tr>
<tr><td>substr</td><td>提取子字符串</td></tr>
<tr><td>translate</td><td>把字符串翻译成另一种字符集 Translates one set of characters into another.</td></tr>
<tr><td>trim</td><td>移除字符串两侧的空白字符或其他指定字符。</td></tr>
<tr><td>upper</td><td>将字符串中的所有字符转换为它们的大写。</td></tr>
</tbody></table>
</div>
<h2 id="正则函数"><a class="header" href="#正则函数">正则函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>regexp_match</td><td>判断一个字符串是否匹配正则表达式</td></tr>
<tr><td>regexp_replace</td><td>使用新字符串替换正则匹配的字符串中内容</td></tr>
</tbody></table>
</div>
<h2 id="时间函数"><a class="header" href="#时间函数">时间函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>to_timestamp</td><td>将字符串转换为 Timestamp(Nanoseconds，None)类型。</td></tr>
<tr><td>to_timestamp_millis</td><td>将字符串转换为 Timestamp(Milliseconds，None)类型。</td></tr>
<tr><td>to_timestamp_micros</td><td>将字符串转换为 Timestamp(Microseconds，None)类型。</td></tr>
<tr><td>to_timestamp_seconds</td><td>将字符串转换为 Timestamp(Seconds，None)类型。</td></tr>
<tr><td>extract</td><td>从日期/时间值中检索年份或小时等子字段。</td></tr>
<tr><td>date_part</td><td>从日期/时间值中检索子字段。</td></tr>
<tr><td>date_trunc</td><td>将日期/时间值截断到指定的精度。</td></tr>
<tr><td>date_bin</td><td>将日期/时间值按指定精度进行分组。</td></tr>
<tr><td>from_unixtime</td><td>将 Unix 时代转换为 Timestamp(Nanoseconds，None)类型。</td></tr>
<tr><td>now</td><td>作为 Timestamp(Nanoseconds，UTC)返回当前时间。</td></tr>
</tbody></table>
</div>
<h2 id="其他函数"><a class="header" href="#其他函数">其他函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>描述</th></tr></thead><tbody>
<tr><td>array</td><td>创建有一个数组</td></tr>
<tr><td>arrow_typeof</td><td>返回内置的数据类型</td></tr>
<tr><td>in_list</td><td>检测数值是否在 list 里面</td></tr>
<tr><td>random</td><td>生成随机值</td></tr>
<tr><td>sha224</td><td>sha224</td></tr>
<tr><td>sha256</td><td>sha256</td></tr>
<tr><td>sha384</td><td>sha384</td></tr>
<tr><td>sha512</td><td>sha512</td></tr>
<tr><td>to_hex</td><td>转换为 16 进制</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h1>
<p>HoraeDB SQL 基于 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 实现，支持的聚合函数如下。更多详情请参考： <a href="https://github.com/apache/arrow-datafusion/blob/master/docs/source/user-guide/sql/aggregate_functions.md">Datafusion</a></p>
<h2 id="常用"><a class="header" href="#常用">常用</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>min</td><td>最小值</td></tr>
<tr><td>max</td><td>最大值</td></tr>
<tr><td>count</td><td>求行数</td></tr>
<tr><td>avg</td><td>平均值</td></tr>
<tr><td>sum</td><td>求和</td></tr>
<tr><td>array_agg</td><td>把数据放到一个数组</td></tr>
</tbody></table>
</div>
<h2 id="统计"><a class="header" href="#统计">统计</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>var / var_samp</td><td>返回给定列的样本方差</td></tr>
<tr><td>var_pop</td><td>返回给定列的总体方差</td></tr>
<tr><td>stddev / stddev_samp</td><td>返回给定列的样本标准差</td></tr>
<tr><td>stddev_pop</td><td>返回给定列的总体标准差</td></tr>
<tr><td>covar / covar_samp</td><td>返回给定列的样本协方差</td></tr>
<tr><td>covar_pop</td><td>返回给定列的总体协方差</td></tr>
<tr><td>corr</td><td>返回给定列的相关系数</td></tr>
</tbody></table>
</div>
<h2 id="估值函数"><a class="header" href="#估值函数">估值函数</a></h2>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td>approx_distinct</td><td>返回输入值的近似去重数量（HyperLogLog）</td></tr>
<tr><td>approx_median</td><td>返回输入值的近似中位数，它是 approx_percentile_cont(x, 0.5) 的简单写法</td></tr>
<tr><td>approx_percentile_cont</td><td>返回输入值的近似百分位数（TDigest），其中 p 是 0 和 1（包括）之间的 float64，等同于 approx_percentile_cont_with_weight(x, 1, p)</td></tr>
<tr><td>approx_percentile_cont_with_weight</td><td>返回输入值带权重的近似百分位数（TDigest），其中 w 是权重列表达式，p 是 0 和 1（包括）之间的 float64</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="集群部署"><a class="header" href="#集群部署">集群部署</a></h1>
<p>在<a href="cluster_deployment/../quick_start.html">快速开始</a>部分我们已经介绍过单机版本 HoraeDB 的部署。</p>
<p>除此之外，HoraeDB 作为一个分布式时序数据库，多个 HoraeDB 实例能够以集群的方式提供可伸缩和高可用的数据服务。</p>
<p>由于目前 HoraeDB 对于 Kubernetes 的支持还在开发之中，目前 HoraeDB 集群部署只能通过手动完成，集群部署的模式主要有两种，两者的区别在于是否需要部署 HoraeMeta，对于 <code>NoMeta</code> 的模式，我们仅建议在测试场景下使用。</p>
<ul>
<li><a href="cluster_deployment/no_meta.html">NoMeta 模式(仅供测试使用)</a></li>
<li><a href="cluster_deployment/with_meta.html">WithMeta 模式</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>作为一个开源的数据库，HoraeDB 可以部署在基于英特尔 /ARM 架构的服务器，以及常见的虚拟环境。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">OS</th><th style="text-align: center">status</th></tr></thead><tbody>
<tr><td style="text-align: center">Ubuntu LTS 16.06 or later</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">CentOS 7.3 or later</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">Red Hat Enterprise Linux 7.3 or later 7.x releases</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">macOS 11 or later</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">Windows</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<ul>
<li>生产环境下 , Linux 是首选平台。</li>
<li>macOS 主要用在开发环境。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><strong>注意：此功能仅供测试使用，不推荐生产使用，相关功能将来可能会发生变化。</strong></p>
<h1 id="nometa-模式"><a class="header" href="#nometa-模式">NoMeta 模式</a></h1>
<p>本章介绍如何部署一个静态（无 HoraeMeta）的 HoraeDB 集群。</p>
<p>在没有 HoraeMeta 的情况下，利用 HoraeDB 服务端针对表名提供了可配置的路由功能即可实现集群化部署，为此我们需要提供一个包含路由规则的正确配置。根据这个配置，请求会被发送到集群中的每个 HoraeDB 实例。</p>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>本文的目标是：在同一台机器上部署一个集群，这个集群包含两个 HoraeDB 实例。</p>
<p>如果想要部署一个更大规模的集群，参考此方案也可以进行部署。</p>
<h2 id="准备配置文件"><a class="header" href="#准备配置文件">准备配置文件</a></h2>
<h3 id="基础配置"><a class="header" href="#基础配置">基础配置</a></h3>
<p>HoraeDB 的基础配置如下：</p>
<pre><code class="language-toml">[server]
bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831

[logger]
level = &quot;info&quot;

[tracing]
dir = &quot;/tmp/horaedb&quot;

[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/tmp/horaedb&quot;

[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/tmp/horaedb&quot;
</code></pre>
<p>为了在同一个机器上部署两个实例，我们需要为每个实例配置不同的服务端口和数据目录。</p>
<p>实例 <code>HoraeDB_0</code> 的配置如下：</p>
<pre><code class="language-toml">[server]
bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831

[logger]
level = &quot;info&quot;

[tracing]
dir = &quot;/tmp/horaedb_0&quot;

[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/tmp/horaedb_0&quot;

[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/tmp/horaedb_0&quot;
</code></pre>
<p>实例 <code>HoraeDB_1</code> 的配置如下：</p>
<pre><code class="language-toml">[server]
bind_addr = &quot;0.0.0.0&quot;
http_port = 15440
grpc_port = 18831

[logger]
level = &quot;info&quot;

[tracing]
dir = &quot;/tmp/horaedb_1&quot;

[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/tmp/horaedb_1&quot;

[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/tmp/horaedb_1&quot;
</code></pre>
<h3 id="schema-和-shard"><a class="header" href="#schema-和-shard">Schema 和 Shard</a></h3>
<p>接下来我们需要定义 <code>Schema</code> 和分片以及路由规则。</p>
<p>如下定义了 <code>Schema</code> 和分片：</p>
<pre><code class="language-toml">[cluster_deployment]
mode = &quot;NoMeta&quot;

[[cluster_deployment.topology.schema_shards]]
schema = 'public_0'
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 0
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 1
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831

[[cluster_deployment.topology.schema_shards]]
schema = 'public_1'
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 0
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 1
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 18831
</code></pre>
<p>上述的配置中，定义了两个 <code>Schema</code>：</p>
<ul>
<li><code>public_0</code> 有两个分片在 <code>HoraeDB_0</code> 实例上。</li>
<li><code>public_1</code> 有两个分片同时在 <code>HoraeDB_0</code> 和 <code>HoraeDB_1</code> 实例上。</li>
</ul>
<h3 id="路由规则"><a class="header" href="#路由规则">路由规则</a></h3>
<p>定义 <code>Schema</code> 和分片后，需要定义路由规则，如下是一个前缀路由规则：</p>
<pre><code class="language-toml">[[cluster_deployment.route_rules.prefix_rules]]
schema = 'public_0'
prefix = 'prod_'
shard = 0
</code></pre>
<p>在这个规则里，<code>public_0</code> 中表名以 <code>prod_</code> 为前缀的所有表属于，相关操作会被路由到 <code>shard_0</code> 也就是 <code>HoraeDB_0</code> 实例。 <code>public_0</code> 中其他的表会以 hash 的方式路由到 <code>shard_0</code> 和 <code>shard_1</code>.</p>
<p>在前缀规则之外，我们也可以定义一个 hash 规则：</p>
<pre><code class="language-toml">[[cluster_deployment.route_rules.hash_rules]]
schema = 'public_1'
shards = [0, 1]
</code></pre>
<p>这个规则告诉 HoraeDB, <code>public_1</code> 的所有表会被路由到 <code>public_1</code> 的 <code>shard_0</code> and <code>shard_1</code>, 也就是 <code>HoraeDB0</code> 和 <code>HoraeDB_1</code>.
实际上如果没有定义 <code>public_1</code> 的路由规则，这是默认的路由行为。</p>
<p><code>HoraeDB_0</code> 和 <code>HoraeDB_1</code> 实例完整的配置文件如下：</p>
<pre><code class="language-toml">[server]
bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831

[logger]
level = &quot;info&quot;

[tracing]
dir = &quot;/tmp/horaedb_0&quot;

[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/tmp/horaedb_0&quot;

[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/tmp/horaedb_0&quot;

[cluster_deployment]
mode = &quot;NoMeta&quot;

[[cluster_deployment.topology.schema_shards]]
schema = 'public_0'
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 0
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 1
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831

[[cluster_deployment.topology.schema_shards]]
schema = 'public_1'
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 0
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 1
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 18831
</code></pre>
<pre><code class="language-toml">[server]
bind_addr = &quot;0.0.0.0&quot;
http_port = 15440
grpc_port = 18831

[logger]
level = &quot;info&quot;

[tracing]
dir = &quot;/tmp/horaedb_1&quot;

[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/tmp/horaedb_1&quot;

[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/tmp/horaedb_1&quot;

[cluster_deployment]
mode = &quot;NoMeta&quot;

[[cluster_deployment.topology.schema_shards]]
schema = 'public_0'
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 0
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 1
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831

[[cluster_deployment.topology.schema_shards]]
schema = 'public_1'
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 0
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[cluster_deployment.topology.schema_shards.shard_views]]
shard_id = 1
[cluster_deployment.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 18831
</code></pre>
<p>我们给这两份不同的配置文件分别命名为 <code>config_0.toml</code> 和 <code>config_1.toml</code>；
但是在实际环境中不同的实例可以部署在不同的服务器上，也就是说，不同的实例没有必要设置不同的服务端口和数据目录，这种情况下实例的配置可以使用同一份配置文件。</p>
<h2 id="启动-horaedb"><a class="header" href="#启动-horaedb">启动 HoraeDB</a></h2>
<p>配置准备好后，我们就可以开始启动 HoraeDB 容器了。</p>
<p>启动命令如下：</p>
<pre><code class="language-shell">sudo docker run -d -t --name horaedb_0 -p 5440:5440 -p 8831:8831 -v $(pwd)/config_0.toml:/etc/horaedb/horaedb.toml horaedb/horaedb-server
sudo docker run -d -t --name horaedb_1 -p 15440:15440 -p 18831:18831 -v $(pwd)/config_1.toml:/etc/horaedb/horaedb.toml horaedb/horaedb-server
</code></pre>
<p>容器启动成功后，两个实例的 HoraeDB 集群就搭建完成了，可以开始提供读写服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withmeta-模式"><a class="header" href="#withmeta-模式">WithMeta 模式</a></h1>
<p>本文展示如何部署一个由 HoraeMeta 控制的 HoraeDB 集群，有了 HoraeMeta 提供的服务，如果 HoraeDB 使用存储不在本地的话，就可以实现很多分布式特性，比如水平扩容、负载均衡、服务高可用等。</p>
<h2 id="部署-horaemeta"><a class="header" href="#部署-horaemeta">部署 HoraeMeta</a></h2>
<p>HoraeMeta 是 HoraeDB 分布式模式的核心服务之一，用于管理 HoraeDB 节点的调度，为 HoraeDB 集群提供高可用、负载均衡、集群管控等能力。
HoraeMeta 本身通过嵌入式的 <a href="https://github.com/etcd-io/etcd">ETCD</a> 保障高可用。此外，ETCD 的服务也被暴露给 HoraeDB 用于实现分布式锁使用。</p>
<h3 id="编译打包"><a class="header" href="#编译打包">编译打包</a></h3>
<ul>
<li>安装 Golang，版本号 &gt;= 1.19。</li>
<li>在项目根目录下使用 <code>make build</code> 进行编译打包。</li>
</ul>
<h3 id="部署方式"><a class="header" href="#部署方式">部署方式</a></h3>
<h4 id="启动配置"><a class="header" href="#启动配置">启动配置</a></h4>
<p>目前 HoraeMeta 支持以配置文件和环境变量两种方式来指定服务启动配置。我们提供了配置文件方式启动的示例，具体可以参考 <a href="https://github.com/apache/incubator-horaedb-meta/tree/main/config">config</a>。
环境变量的配置优先级高于配置文件，当同时存在时，以环境变量为准。</p>
<h4 id="动态拓扑和静态拓扑"><a class="header" href="#动态拓扑和静态拓扑">动态拓扑和静态拓扑</a></h4>
<p>即使使用了 HoraeMeta 来部署 HoraeDB 集群，也可以选择静态拓扑或动态拓扑。对于静态拓扑，表的分布在集群初始化后是静态的，而对于动态拓扑，表可以在不同的 HoraeDB 节点之间进行动态迁移以达到负载平衡或者 failover 的目的。但是动态拓扑只有在 HoraeDB 节点使用的存储是非本地的情况下才能启用，否则会因为表的数据是持久化在本地，当表转移到不同的 HoraeDB 节点时会导致数据损坏。</p>
<p>目前，HoraeMeta 默认关闭集群拓扑的动态调度，并且在本篇指南中，这个选项也不会被开启，因为指南中的例子采用的是本地存储。如果要启用动态调度，可以将 <code>TOPOLOGY_TYPE</code> 设置为 <code>dynamic</code>（默认为 <code>static</code>），之后负载均衡和 failover 将会起作用。但是需要注意的是，如果底层存储是本地磁盘，则不要启用它。</p>
<p>此外对于静态拓扑，参数 <code>DEFAULT_CLUSTER_NODE_COUNT</code> 表示已部署集群中 HoraeDB 节点的数量，应该被设置为 HoraeDB 服务器的实际机器数，这个参数非常重要，因为集群初始化完毕之后，HoraeDB 集群将无法再增减机器。</p>
<h4 id="启动实例"><a class="header" href="#启动实例">启动实例</a></h4>
<p>HoraeMeta 基于 etcd 实现高可用，在线上环境我们一般部署多个节点，但是在本地环境和测试时，可以直接部署单个节点来简化整个部署流程。</p>
<ul>
<li>单节点</li>
</ul>
<pre><code class="language-bash">docker run -d --name horaemeta-server \
  -p 2379:2379 \
  ghcr.io/apache/horaemeta-server:nightly-20231225-ab067bf0
</code></pre>
<ul>
<li>多节点</li>
</ul>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/apache/incubator-horaedb-docs/main/docs/src/resources/config-horaemeta-cluster0.toml

docker run -d --network=host --name horaemeta-server0 \
  -v $(pwd)/config-horaemeta-cluster0.toml:/etc/horaemeta/horaemeta.toml \
  ghcr.io/apache/horaemeta-server:nightly-20231225-ab067bf0

wget https://raw.githubusercontent.com/apache/incubator-horaedb-docs/main/docs/src/resources/config-horaemeta-cluster1.toml

docker run -d --network=host --name horaemeta-server1 \
  -v $(pwd)/config-horaemeta-cluster1.toml:/etc/horaemeta/horaemeta.toml \
  ghcr.io/apache/horaemeta-server:nightly-20231225-ab067bf0

wget https://raw.githubusercontent.com/apache/incubator-horaedb-docs/main/docs/src/resources/config-horaemeta-cluster2.toml

docker run -d --network=host --name horaemeta-server2 \
  -v $(pwd)/config-horaemeta-cluster2.toml:/etc/horaemeta/horaemeta.toml \
  ghcr.io/apache/horaemeta-server:nightly-20231225-ab067bf0
</code></pre>
<p>如果 HoraeDB 底层采用的是远程存储，可以环境变量来开启动态调度：只需将 <code>-e ENABLE_SCHEDULE=true</code> 加入到 docker run 命令中去。</p>
<h2 id="部署-horaedb"><a class="header" href="#部署-horaedb">部署 HoraeDB</a></h2>
<p>在 <code>NoMeta</code> 模式中，由于 HoraeDB 集群拓扑是静态的，因此 HoraeDB 只需要一个本地存储来作为底层的存储层即可。但是在 <code>WithMeta</code> 模式中，集群的拓扑是可以变化的，因此如果 HoraeDB 的底层存储使用一个独立的存储服务的话，HoraeDB 集群就可以获得分布式系统的一些特性：高可用、负载均衡、水平扩展等。
当然，HoraeDB 仍然可以使用本地存储，这样的话，集群的拓扑仍然是静态的。</p>
<p>存储相关的配置主要包括两个部分：</p>
<ul>
<li>Object Storage</li>
<li>WAL Storage</li>
</ul>
<p>注意：在生产环境中如果我们把 HoraeDB 部署在多个节点上时，请按照如下方式把机器的网络地址设置到环境变量中：</p>
<pre><code class="language-shell">export HORAEDB_SERVER_ADDR=&quot;{server_addr}:8831&quot;
</code></pre>
<p>注意，此网络地址用于 HoraeMeta 和 HoraeDB 通信使用，需保证网络联通可用。</p>
<h3 id="object-storage"><a class="header" href="#object-storage">Object Storage</a></h3>
<h4 id="本地存储"><a class="header" href="#本地存储">本地存储</a></h4>
<p>类似 <code>NoMeta</code> 模式，我们仍然可以为 HoraeDB 配置一个本地磁盘作为底层存储：</p>
<pre><code class="language-toml">[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/home/admin/data/horaedb&quot;
</code></pre>
<h4 id="oss"><a class="header" href="#oss">OSS</a></h4>
<p>Aliyun OSS 也可以作为 HoraeDB 的底层存储，以此提供数据容灾能力。下面是一个配置示例，示例中的模版变量需要被替换成实际的 OSS 参数才可以真正的使用：</p>
<pre><code class="language-toml">[analytic.storage.object_store]
type = &quot;Aliyun&quot;
key_id = &quot;{key_id}&quot;
key_secret = &quot;{key_secret}&quot;
endpoint = &quot;{endpoint}&quot;
bucket = &quot;{bucket}&quot;
prefix = &quot;{data_dir}&quot;
</code></pre>
<h4 id="s3"><a class="header" href="#s3">S3</a></h4>
<p>Amazon S3 也可以作为 HoraeDB 的底层存储，下面是一个配置示例，示例中的模版变量需要被替换成实际的 S3 参数才可以真正的使用：</p>
<pre><code class="language-toml">[analytic.storage.object_store]
type = &quot;S3&quot;
region = &quot;{region}&quot;
key_id = &quot;{key_id}&quot;
key_secret = &quot;{key_secret}&quot;
endpoint = &quot;{endpoint}&quot;
bucket = &quot;{bucket}&quot;
prefix = &quot;{prefix}&quot;
</code></pre>
<h3 id="wal-storage"><a class="header" href="#wal-storage">WAL Storage</a></h3>
<h4 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h4>
<p>基于 RocksDB 的 WAL 也是一种本地存储，无第三方依赖，可以很方便的快速部署：</p>
<pre><code class="language-toml">[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/home/admin/data/horaedb&quot;
</code></pre>
<h4 id="oceanbase"><a class="header" href="#oceanbase">OceanBase</a></h4>
<p>如果已经有了一个部署好的 OceanBase 集群的话，HoraeDB 可以使用它作为 WAL Storage 来保证其数据的容灾性。下面是一个配置示例，示例中的模版变量需要被替换成实际的 OceanBase 集群的参数才可以真正的使用：</p>
<pre><code class="language-toml">[analytic.wal]
type = &quot;Obkv&quot;

[analytic.wal.data_namespace]
ttl = &quot;365d&quot;

[analytic.wal.obkv]
full_user_name = &quot;{full_user_name}&quot;
param_url = &quot;{param_url}&quot;
password = &quot;{password}&quot;

[analytic.wal.obkv.client]
sys_user_name = &quot;{sys_user_name}&quot;
sys_password = &quot;{sys_password}&quot;
</code></pre>
<h4 id="kafka"><a class="header" href="#kafka">Kafka</a></h4>
<p>如果你已经部署了一个 Kafka 集群，HoraeDB 可以也可以使用它作为 WAL Storage。下面是一个配置示例，示例中的模版变量需要被替换成实际的 Kafka 集群的参数才可以真正的使用：</p>
<pre><code class="language-toml">[analytic.wal]
type = &quot;Kafka&quot;

[analytic.wal.kafka.client]
boost_broker = &quot;{boost_broker}&quot;
</code></pre>
<h4 id="meta-客户端配置"><a class="header" href="#meta-客户端配置">Meta 客户端配置</a></h4>
<p>除了存储层的配置外，HoraeDB 需要 HoraeMeta 相关的配置来与 HoraeMeta 集群进行通信：</p>
<pre><code>[cluster.meta_client]
cluster_name = 'defaultCluster'
meta_addr = 'http://{HoraeMetaAddr}:2379'
lease = &quot;10s&quot;
timeout = &quot;5s&quot;

[cluster_deployment.etcd_client]
server_addrs = ['http://{HoraeMetaAddr}:2379']
</code></pre>
<h3 id="完整配置"><a class="header" href="#完整配置">完整配置</a></h3>
<p>将上面提到的所有关键配置合并之后，我们可以得到一个完整的、可运行的配置。为了让这个配置可以直接运行起来，配置中均采用了本地存储：基于 RocksDB 的 WAL 和本地磁盘的 Object Storage：</p>
<pre><code class="language-toml">[server]
bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831

[logger]
level = &quot;info&quot;

[runtime]
read_thread_num = 20
write_thread_num = 16
background_thread_num = 12

[cluster_deployment]
mode = &quot;WithMeta&quot;

[cluster_deployment.meta_client]
cluster_name = 'defaultCluster'
meta_addr = 'http://127.0.0.1:2379'
lease = &quot;10s&quot;
timeout = &quot;5s&quot;

[cluster_deployment.etcd_client]
server_addrs = ['127.0.0.1:2379']

[analytic]
write_group_worker_num = 16
replay_batch_size = 100
max_replay_tables_per_batch = 128
write_group_command_channel_cap = 1024
sst_background_read_parallelism = 8

[analytic.manifest]
scan_batch_size = 100
snapshot_every_n_updates = 10000
scan_timeout = &quot;5s&quot;
store_timeout = &quot;5s&quot;

[analytic.wal]
type = &quot;RocksDB&quot;
data_dir = &quot;/home/admin/data/horaedb&quot;

[analytic.storage]
mem_cache_capacity = &quot;20GB&quot;
# 1&lt;&lt;8=256
mem_cache_partition_bits = 8

[analytic.storage.object_store]
type = &quot;Local&quot;
data_dir = &quot;/home/admin/data/horaedb/&quot;

[analytic.table_opts]
arena_block_size = 2097152
write_buffer_size = 33554432

[analytic.compaction]
schedule_channel_len = 16
schedule_interval = &quot;30m&quot;
max_ongoing_tasks = 8
memory_limit = &quot;4G&quot;
</code></pre>
<p>将这个配置命名成 <code>config.toml</code>。至于使用远程存储的配置示例在下面我们也提供了，需要注意的是，配置中的相关参数需要被替换成实际的参数才能真正使用：</p>
<ul>
<li><a href="cluster_deployment/../../resources/config_local_oss.toml">本地 RocksDB WAL + OSS</a></li>
<li><a href="cluster_deployment/../../resources/config_obkv_oss.toml">OceanBase WAL + OSS</a></li>
<li><a href="cluster_deployment/../../resources/config_kafka_oss.toml">Kafka WAL + OSS</a></li>
</ul>
<h3 id="启动集群"><a class="header" href="#启动集群">启动集群</a></h3>
<p>首先，我们先启动 HoraeMeta：</p>
<pre><code class="language-bash">docker run -d --name horaemeta-server \
  -p 2379:2379 \
  ghcr.io/apache/horaemeta-server:nightly-20231225-ab067bf0
</code></pre>
<p>HoraeMeta 启动好了，没有问题之后，就可以把 HoraeDB 的容器创建出来：
TODO: 补充完整</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-文档"><a class="header" href="#sdk-文档">SDK 文档</a></h1>
<ul>
<li><a href="sdk/./rust.html">Rust</a></li>
<li><a href="sdk/./java.html">Java</a></li>
<li><a href="sdk/./python.html">Python</a></li>
<li><a href="sdk/./go.html">Go</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-客户端使用文档"><a class="header" href="#java-客户端使用文档">Java 客户端使用文档</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>HoraeDBClient 是 HoraeDB 的高性能 Java 版客户端。</p>
<h2 id="环境要求"><a class="header" href="#环境要求">环境要求</a></h2>
<p>Java 8 及以上</p>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;io.ceresdb&lt;/groupId&gt;
  &lt;artifactId&gt;ceresdb-all&lt;/artifactId&gt;
  &lt;version&gt;${CERESDB.VERSION}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>最新的版本可以从<a href="https://github.com/apache/incubator-horaedb-client-java/blob/main/docs/CHANGELOG.md">这里</a>获取。</p>
<h2 id="初始化客户端"><a class="header" href="#初始化客户端">初始化客户端</a></h2>
<pre><code class="language-java">// CeresDB options
final CeresDBOptions opts = CeresDBOptions.newBuilder(&quot;127.0.0.1&quot;, 8831, DIRECT) // 默认 gprc 端口号，DIRECT 模式
        .database(&quot;public&quot;) // Client所使用的database，可被RequestContext的database覆盖
        .writeMaxRetries(1) // 写入失败重试次数上限（只有部分错误 code 才会重试，比如路由表失效）
        .readMaxRetries(1)  // 查询失败重试次数上限（只有部分错误 code 才会重试，比如路由表失效）
        .build();

final CeresDBClient client = new CeresDBClient();
if (!client.init(opts)) {
    throw new IllegalStateException(&quot;Fail to start CeresDBClient&quot;);
}
</code></pre>
<p>客户端初始化至少需要三个参数：</p>
<ul>
<li>EndPoint： 127.0.0.1</li>
<li>Port： 8831</li>
<li>RouteMode： DIRECT/PROXY</li>
</ul>
<p>这里重点解释下 <code>RouteMode</code> 参数，<code>PROXY</code> 模式用在客户端和服务端存在网络隔离，请求需要经过转发的场景；<code>DIRECT</code> 模式用在客户端和服务端网络连通的场景，节省转发的开销，具有更高的性能。
更多的参数配置详情见 <a href="https://github.com/apache/incubator-horaedb-client-java/tree/main/docs/configuration.md">configuration</a>。</p>
<p>注意： HoraeDB 当前仅支持默认的 <code>public</code> database , 未来会支持多个 database。</p>
<h2 id="建表-1"><a class="header" href="#建表-1">建表</a></h2>
<p>为了方便使用，在使用 gRPC 的 write 接口进行写入时，如果某个表不存在，HoraeDB 会根据第一次的写入自动创建一个表。</p>
<p>当然你也可以通过 <code>create table</code> 语句来更精细化的管理的表（比如添加索引等）。</p>
<p>下面的建表语句（使用 SDK 的 SQL API）包含了 HoraeDB 支持的所有字段类型：</p>
<pre><code class="language-java">String createTableSql = &quot;CREATE TABLE IF NOT EXISTS machine_table(&quot; +
        &quot;ts TIMESTAMP NOT NULL,&quot; +
        &quot;city STRING TAG NOT NULL,&quot; +
        &quot;ip STRING TAG NOT NULL,&quot; +
        &quot;cpu DOUBLE NULL,&quot; +
        &quot;mem DOUBLE NULL,&quot; +
        &quot;TIMESTAMP KEY(ts)&quot; + // 建表时必须指定时间戳序列
        &quot;) ENGINE=Analytic&quot;;

Result&lt;SqlQueryOk, Err&gt; createResult = client.sqlQuery(new SqlQueryRequest(createTableSql)).get();
if (!createResult.isOk()) {
        throw new IllegalStateException(&quot;Fail to create table&quot;);
}
</code></pre>
<h2 id="删表"><a class="header" href="#删表">删表</a></h2>
<p>下面是一个删表的示例：</p>
<pre><code class="language-java">String dropTableSql = &quot;DROP TABLE machine_table&quot;;

Result&lt;SqlQueryOk, Err&gt; dropResult = client.sqlQuery(new SqlQueryRequest(dropTableSql)).get();
if (!dropResult.isOk()) {
        throw new IllegalStateException(&quot;Fail to drop table&quot;);
}
</code></pre>
<h2 id="数据写入"><a class="header" href="#数据写入">数据写入</a></h2>
<p>首先我们需要构建数据，示例如下：</p>
<pre><code class="language-java">List&lt;Point&gt; pointList = new LinkedList&lt;&gt;();
for (int i = 0; i &lt; 100; i++) {
    // 构建单个Point
    final Point point = Point.newPointBuilder(&quot;machine_table&quot;)
            .setTimestamp(t0)
            .addTag(&quot;city&quot;, &quot;Singapore&quot;)
            .addTag(&quot;ip&quot;, &quot;10.0.0.1&quot;)
            .addField(&quot;cpu&quot;, Value.withDouble(0.23))
            .addField(&quot;mem&quot;, Value.withDouble(0.55))
            .build();
    points.add(point);
}
</code></pre>
<p>然后使用 <code>write</code> 接口写入数据，示例如下：</p>
<pre><code class="language-java">final CompletableFuture&lt;Result&lt;WriteOk, Err&gt;&gt; wf = client.write(pointList);
// 这里用 `future.get` 只是方便演示，推荐借助 CompletableFuture 强大的 API 实现异步编程
final Result&lt;WriteOk, Err&gt; writeResult = wf.get();

Assert.assertTrue(writeResult.isOk());
Assert.assertEquals(3, writeResult.getOk().getSuccess());
// `Result` 类参考了 Rust 语言，提供了丰富的 mapXXX、andThen 类 function 方便对结果值进行转换，提高编程效率，欢迎参考 API 文档使用
Assert.assertEquals(3, writeResult.mapOr(0, WriteOk::getSuccess).intValue());
Assert.assertEquals(0, writeResult.getOk().getFailed());
Assert.assertEquals(0, writeResult.mapOr(-1, WriteOk::getFailed).intValue());
</code></pre>
<p>详情见 <a href="https://github.com/apache/incubator-horaedb-client-java/tree/main/docs/write.md">write</a></p>
<h2 id="数据查询"><a class="header" href="#数据查询">数据查询</a></h2>
<pre><code class="language-java">final SqlQueryRequest queryRequest = SqlQueryRequest.newBuilder()
        .forTables(&quot;machine_table&quot;) // 这里表名是可选的，如果未提供，SDK将自动解析SQL填充表名并自动路由
        .sql(&quot;select * from machine_table where ts = %d&quot;, t0) //
        .build();
final CompletableFuture&lt;Result&lt;SqlQueryOk, Err&gt;&gt; qf = client.sqlQuery(queryRequest);
// 这里用 `future.get` 只是方便演示，推荐借助 CompletableFuture 强大的 API 实现异步编程
final Result&lt;SqlQueryOk, Err&gt; queryResult = qf.get();

Assert.assertTrue(queryResult.isOk());

final SqlQueryOk queryOk = queryResult.getOk();
Assert.assertEquals(1, queryOk.getRowCount());

// 直接获取结果数组
final List&lt;Row&gt; rows = queryOk.getRowList();
Assert.assertEquals(t0, rows.get(0).getColumn(&quot;ts&quot;).getValue().getTimestamp());
Assert.assertEquals(&quot;Singapore&quot;, rows.get(0).getColumn(&quot;city&quot;).getValue().getString());
Assert.assertEquals(&quot;10.0.0.1&quot;, rows.get(0).getColumn(&quot;ip&quot;).getValue().getString());
Assert.assertEquals(0.23, rows.get(0).getColumn(&quot;cpu&quot;).getValue().getDouble(), 0.0000001);
Assert.assertEquals(0.55, rows.get(0).getColumn(&quot;mem&quot;).getValue().getDouble(), 0.0000001);

// 获取结果流
final Stream&lt;Row&gt; rowStream = queryOk.stream();
rowStream.forEach(row -&gt; System.out.println(row.toString()));
</code></pre>
<p>详情见 <a href="https://github.com/apache/incubator-horaedb-client-java/tree/main/docs/read.md">read</a></p>
<h2 id="流式读写"><a class="header" href="#流式读写">流式读写</a></h2>
<p>HoraeDB 支持流式读写，适用于大规模数据读写。</p>
<pre><code class="language-java">long start = System.currentTimeMillis();
long t = start;
final StreamWriteBuf&lt;Point, WriteOk&gt; writeBuf = client.streamWrite(&quot;machine_table&quot;);
for (int i = 0; i &lt; 1000; i++) {
        final Point streamData = Point.newPointBuilder(&quot;machine_table&quot;)
                .setTimestamp(t)
                .addTag(&quot;city&quot;, &quot;Beijing&quot;)
                .addTag(&quot;ip&quot;, &quot;10.0.0.3&quot;)
                .addField(&quot;cpu&quot;, Value.withDouble(0.42))
                .addField(&quot;mem&quot;, Value.withDouble(0.67))
                .build();
        writeBuf.writeAndFlush(Collections.singletonList(streamData));
        t = t+1;
}
final CompletableFuture&lt;WriteOk&gt; writeOk = writeBuf.completed();
Assert.assertEquals(1000, writeOk.join().getSuccess());

final SqlQueryRequest streamQuerySql = SqlQueryRequest.newBuilder()
        .sql(&quot;select * from %s where city = '%s' and ts &gt;= %d and ts &lt; %d&quot;, &quot;machine_table&quot;, &quot;Beijing&quot;, start, t).build();
final Result&lt;SqlQueryOk, Err&gt; streamQueryResult = client.sqlQuery(streamQuerySql).get();
Assert.assertTrue(streamQueryResult.isOk());
Assert.assertEquals(1000, streamQueryResult.getOk().getRowCount());
</code></pre>
<p>详情见 <a href="https://github.com/apache/incubator-horaedb-client-java/tree/main/docs/streaming.md">streaming</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<pre><code>go get github.com/apache/incubator-horaedb-client-go
</code></pre>
<p>你可以在这里找到最新的版本 <a href="https://github.com/apache/incubator-horaedb-client-go/tags">here</a>.</p>
<h2 id="如何使用"><a class="header" href="#如何使用">如何使用</a></h2>
<h3 id="初始化客户端-1"><a class="header" href="#初始化客户端-1">初始化客户端</a></h3>
<pre><code class="language-go">	client, err := horaedb.NewClient(endpoint, horaedb.Direct,
		horaedb.WithDefaultDatabase(&quot;public&quot;), // Client所使用的database
	)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody>
<tr><td>defaultDatabase</td><td>所使用的 database，可以被单个 <code>Write</code> 或者 <code>SQLRequest</code> 请求中的 database 覆盖</td></tr>
<tr><td>RPCMaxRecvMsgSize</td><td>grpc <code>MaxCallRecvMsgSize</code> 配置, 默认是 1024 _ 1024 _ 1024</td></tr>
<tr><td>RouteMaxCacheSize</td><td>如果 router 客户端中的 路由缓存超过了这个值，将会淘汰最不活跃的直至降低这个阈值, 默认是 10000</td></tr>
</tbody></table>
</div>
<p>注意： HoraeDB 当前仅支持预创建的 <code>public</code> database , 未来会支持多个 database。</p>
<h3 id="管理表"><a class="header" href="#管理表">管理表</a></h3>
<p>HoraeDB 使用 SQL 来管理表格，比如创建表、删除表或者新增列等等，这和你在使用 SQL 管理其他的数据库时没有太大的区别。</p>
<p>为了方便使用，在使用 gRPC 的 write 接口进行写入时，如果某个表不存在，HoraeDB 会根据第一次的写入自动创建一个表。</p>
<p>当然你也可以通过 <code>create table</code> 语句来更精细化的管理的表（比如添加索引等）。</p>
<p><strong>创建表的样例</strong></p>
<pre><code class="language-go">	createTableSQL := `
		CREATE TABLE IF NOT EXISTS demo (
			name string TAG,
			value double,
			t timestamp NOT NULL,
			TIMESTAMP KEY(t)
		) ENGINE=Analytic with (enable_ttl=false)`

	req := horaedb.SQLQueryRequest{
		Tables: []string{&quot;demo&quot;},
		SQL:    createTableSQL,
	}
	resp, err := client.SQLQuery(context.Background(), req)
</code></pre>
<p><strong>删除表的样例</strong></p>
<pre><code class="language-go">	dropTableSQL := `DROP TABLE demo`
	req := horaedb.SQLQueryRequest{
		Tables: []string{&quot;demo&quot;},
		SQL:    dropTableSQL,
	}
	resp, err := client.SQLQuery(context.Background(), req)
</code></pre>
<h3 id="构建写入数据"><a class="header" href="#构建写入数据">构建写入数据</a></h3>
<pre><code class="language-go">	points := make([]horaedb.Point, 0, 2)
	for i := 0; i &lt; 2; i++ {
		point, err := horaedb.NewPointBuilder(&quot;demo&quot;).
			SetTimestamp(now)).
			AddTag(&quot;name&quot;, horaedb.NewStringValue(&quot;test_tag1&quot;)).
			AddField(&quot;value&quot;, horaedb.NewDoubleValue(0.4242)).
			Build()
		if err != nil {
			panic(err)
		}
		points = append(points, point)
	}
</code></pre>
<h3 id="写入数据"><a class="header" href="#写入数据">写入数据</a></h3>
<pre><code class="language-go">	req := horaedb.WriteRequest{
		Points: points,
	}
	resp, err := client.Write(context.Background(), req)
</code></pre>
<h3 id="查询数据"><a class="header" href="#查询数据">查询数据</a></h3>
<pre><code class="language-go">	querySQL := `SELECT * FROM demo`
	req := horaedb.SQLQueryRequest{
		Tables: []string{&quot;demo&quot;},
		SQL:    querySQL,
	}
	resp, err := client.SQLQuery(context.Background(), req)
	if err != nil {
        panic(err)
	}
	fmt.Printf(&quot;query table success, rows:%+v\n&quot;, resp.Rows)
</code></pre>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<p>你可以在<a href="https://github.com/apache/incubator-horaedb-client-go/blob/main/examples/read_write.go">这里</a>找到完整的示例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p><a href="https://pypi.org/project/ceresdb-client/">horaedb-client</a> 是 <a href="https://github.com/apache/incubator-horaedb">HoraeDB</a> python 客户端.</p>
<p>借助于 <a href="https://github.com/PyO3">PyO3</a>，python 客户端的实现实际上是基于 <a href="https://github.com/apache/incubator-horaedb-client-rs">rust 客户端</a> 的封装。</p>
<p>本手册将会介绍 python client 的一些基本用法，其中涉及到的完整示例，可以查看<a href="https://github.com/apache/incubator-horaedb-client-py/blob/main/examples/read_write.py">该示例代码</a>.</p>
<h2 id="环境要求-1"><a class="header" href="#环境要求-1">环境要求</a></h2>
<ul>
<li>Python &gt;= 3.7</li>
</ul>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<pre><code class="language-bash">pip install ceresdb-client
</code></pre>
<p>你可以在这里找到最新的版本 <a href="https://github.com/apache/incubator-horaedb-client-py/tags">here</a>.</p>
<h2 id="初始化客户端-2"><a class="header" href="#初始化客户端-2">初始化客户端</a></h2>
<p>首先介绍下如何初始化客户端，代码示例如下：</p>
<pre><code class="language-python">import asyncio
import datetime
from ceresdb_client import Builder, RpcContext, PointBuilder, ValueBuilder, WriteRequest, SqlQueryRequest, Mode, RpcConfig

rpc_config = RpcConfig()
rpc_config = RpcConfig()
rpc_config.thread_num = 1
rpc_config.default_write_timeout_ms = 1000

builder = Builder('127.0.0.1:8831', Mode.Direct)
builder.set_rpc_config(rpc_config)
builder.set_default_database('public')
client = builder.build()
</code></pre>
<p>代码的最开始部分是依赖库的导入，在后面的示例中将省略这部分。</p>
<p>客户端初始化需要至少两个参数：</p>
<ul>
<li><code>Endpoint</code>： 服务端地址，由 ip 和端口组成，例如 <code>127.0.0.1：8831</code>;</li>
<li><code>Mode</code>: 客户端和服务端通信模式，有两种模式可供选择: <code>Direct</code> 和 <code>Proxy</code>。</li>
</ul>
<p>这里重点介绍下通信模式 <code>Mode</code>， 当客户端可以访问所有的服务器的时候，建议采用 <code>Direct</code> 模式，以减少转发开销；但是如果客户端访问服务器必须要经过网关，那么只能选择 <code>Proxy</code> 模式。</p>
<p>至于 <code>default_database</code>，会在执行 RPC 请求时未通过 <code>RpcContext</code> 设置 database 的情况下，将被作为目标 database 使用。</p>
<p>最后，通过配置 <code>RpcConfig</code>, 可以管理客户端使用的资源和调整其性能，所有的配置参数可以参考<a href="https://github.com/apache/incubator-horaedb-client-py/blob/main/ceresdb_client.pyi">这里</a>.</p>
<h2 id="建表-2"><a class="header" href="#建表-2">建表</a></h2>
<p>为了方便使用，在使用 gRPC 的 write 接口进行写入时，如果某个表不存在，HoraeDB 会根据第一次的写入自动创建一个表。</p>
<p>当然你也可以通过 <code>create table</code> 语句来更精细化的管理的表（比如添加索引等）。</p>
<p>初始化客户端后，建表示例如下：</p>
<pre><code class="language-python">def async_query(client, ctx, req):
    await client.sql_query(ctx, req)

create_table_sql = 'CREATE TABLE IF NOT EXISTS demo ( \
    name string TAG, \
    value double, \
    t timestamp NOT NULL, \
    TIMESTAMP KEY(t)) ENGINE=Analytic with (enable_ttl=false)'

req = SqlQueryRequest(['demo'], create_table_sql)
rpc_ctx = RpcContext()
rpc_ctx.database = 'public'
rpc_ctx.timeout_ms = 100

event_loop = asyncio.get_event_loop()
event_loop.run_until_complete(async_query(client, rpc_ctx, req))
</code></pre>
<p><code>RpcContext</code> 可以用来指定目标 database （可以覆盖在初始化的时候设置的 default_space） 和超时参数。</p>
<h2 id="数据写入-1"><a class="header" href="#数据写入-1">数据写入</a></h2>
<p>可以使用 <code>PointBuilder</code> 来构建一个 point（实际上就是数据集的一行），多个 point 构成一个写入请求。</p>
<p>示例如下:</p>
<pre><code class="language-python">async def async_write(client, ctx, req):
    return await client.write(ctx, req)

point_builder = PointBuilder('demo')
point_builder.set_timestamp(1000 * int(round(datetime.datetime.now().timestamp())))
point_builder.set_tag(&quot;name&quot;, ValueBuilder().string(&quot;test_tag1&quot;))
point_builder.set_field(&quot;value&quot;, ValueBuilder().double(0.4242))
point = point_builder.build()

write_request = WriteRequest()
write_request.add_point(point)

event_loop = asyncio.get_event_loop()
event_loop.run_until_complete(async_write(client, ctx, req))
</code></pre>
<h2 id="数据查询-1"><a class="header" href="#数据查询-1">数据查询</a></h2>
<p>通过 <code>sql_query</code> 接口, 可以方便地从服务端查询数据：</p>
<pre><code>req = SqlQueryRequest(['demo'], 'select * from demo')
event_loop = asyncio.get_event_loop()
resp = event_loop.run_until_complete(async_query(client, ctx, req))
</code></pre>
<p>如示例所展示, 构建 <code>SqlQueryRequest</code> 需要两个参数:</p>
<ul>
<li>查询 sql 中涉及到的表；</li>
<li>查询 sql.</li>
</ul>
<p>当前为了查询的性能，第一个参数是必须的。</p>
<p>查询到数据后，逐行逐列处理数据的示例如下：</p>
<pre><code class="language-python"># Access row by index in the resp.
for row_idx in range(0, resp.num_rows()):
    row_tokens = []
    row = resp.row_by_idx(row_idx)
    for col_idx in range(0, row.num_cols()):
        col = row.column_by_idx(col_idx)
        row_tokens.append(f&quot;{col.name()}:{col.value()}#{col.data_type()}&quot;)
    print(f&quot;row#{row_idx}: {','.join(row_tokens)}&quot;)

# Access row by iter in the resp.
for row in resp.iter_rows():
    row_tokens = []
    for col in row.iter_columns():
        row_tokens.append(f&quot;{col.name()}:{col.value()}#{col.data_type()}&quot;)
    print(f&quot;row: {','.join(row_tokens)}&quot;)
</code></pre>
<h2 id="删表-1"><a class="header" href="#删表-1">删表</a></h2>
<p>和创建表类似，我们可以使用 sql 来删除表：</p>
<pre><code class="language-python">drop_table_sql = 'DROP TABLE demo'

req = SqlQueryRequest(['demo'], drop_table_sql)

event_loop = asyncio.get_event_loop()
event_loop.run_until_complete(async_query(client, rpc_ctx, req))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<pre><code class="language-bash">cargo add ceresdb-client
</code></pre>
<p>你可以在这里找到最新的版本 <a href="https://github.com/apache/incubator-horaedb-client-rs/tags">here</a>.</p>
<h2 id="初始化客户端-3"><a class="header" href="#初始化客户端-3">初始化客户端</a></h2>
<p>首先，我们需要初始化客户端。</p>
<ul>
<li>创建客户端的 builder，你必须设置 <code>endpoint</code> 和 <code>mode</code>：
<ul>
<li><code>endpoint</code> 是类似 &quot;ip/domain_name:port&quot; 形式的字符串。</li>
<li><code>mode</code> 用于指定访问 HoraeDB 服务器的方式，<a href="https://github.com/apache/incubator-horaedb-client-rs/blob/main/src/db_client/builder.rs#L20">关于 mode 的详细信息</a>。</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = Builder::new(&quot;ip/domain_name:port&quot;, Mode::Direct/Mode::Proxy);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>创建和设置 <code>rpc_config</code>，可以按需进行定义或者直接使用默认值，更多详细参数请参考<a href="https://github.com/apache/incubator-horaedb-client-rs/blob/main/src/options.rs">这里</a>：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rpc_config = RpcConfig {
    thread_num: Some(1),
    default_write_timeout: Duration::from_millis(1000),
    ..Default::default()
};
let builder = builder.rpc_config(rpc_config);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>设置 <code>default_database</code>，这会在执行 RPC 请求时未通过 RpcContext 设置 database 的情况下，将被作为目标 database 使用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let builder = builder.default_database(&quot;public&quot;);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>最后，我们从 builder 中创建客户端：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let client = builder.build();
<span class="boring">}</span></code></pre></pre>
<h2 id="管理表-1"><a class="header" href="#管理表-1">管理表</a></h2>
<p>为了方便使用，在使用 gRPC 的 write 接口进行写入时，如果某个表不存在，HoraeDB 会根据第一次的写入自动创建一个表。</p>
<p>当然你也可以通过 <code>create table</code> 语句来更精细化的管理的表（比如添加索引等）。</p>
<ul>
<li>建表:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let create_table_sql = r#&quot;CREATE TABLE IF NOT EXISTS horaedb (
            str_tag string TAG,
            int_tag int32 TAG,
            var_tag varbinary TAG,
            str_field string,
            int_field int32,
            bin_field varbinary,
            t timestamp NOT NULL,
            TIMESTAMP KEY(t)) ENGINE=Analytic with
            (enable_ttl='false')&quot;#;
let req = SqlQueryRequest {
    tables: vec![&quot;horaedb&quot;.to_string()],
    sql: create_table_sql.to_string(),
};

let resp = client
    .sql_query(rpc_ctx, &amp;req)
    .await
    .expect(&quot;Should succeed to create table&quot;);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>删表：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let drop_table_sql = &quot;DROP TABLE horaedb&quot;;
let req = SqlQueryRequest {
    tables: vec![&quot;horaedb&quot;.to_string()],
    sql: drop_table_sql.to_string(),
};

let resp = client
    .sql_query(rpc_ctx, &amp;req)
    .await
    .expect(&quot;Should succeed to create table&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="写入数据-1"><a class="header" href="#写入数据-1">写入数据</a></h2>
<p>我们支持使用类似 <a href="https://awesome.influxdata.com/docs/part-2/influxdb-data-model">InfluxDB</a> 的时序数据模型进行写入。</p>
<ul>
<li>利用 <code>PointBuilder</code> 创建 <code>point</code>，<code>tag value</code> 和 <code>field value</code> 的相关数据结构为 <code>Value</code>，[<code>Value</code> 的详细信息](detail about Value](https://github.com/apache/incubator-horaedb-client-rs/blob/main/src/model/value.rs：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let test_table = &quot;horaedb&quot;;
let ts = Local::now().timestamp_millis();
let point = PointBuilder::new(test_table.to_string())
        .timestamp(ts)
        .tag(&quot;str_tag&quot;.to_string(), Value::String(&quot;tag_val&quot;.to_string()))
        .tag(&quot;int_tag&quot;.to_string(), Value::Int32(42))
        .tag(
            &quot;var_tag&quot;.to_string(),
            Value::Varbinary(b&quot;tag_bin_val&quot;.to_vec()),
        )
        .field(
            &quot;str_field&quot;.to_string(),
            Value::String(&quot;field_val&quot;.to_string()),
        )
        .field(&quot;int_field&quot;.to_string(), Value::Int32(42))
        .field(
            &quot;bin_field&quot;.to_string(),
            Value::Varbinary(b&quot;field_bin_val&quot;.to_vec()),
        )
        .build()
        .unwrap();
<span class="boring">}</span></code></pre></pre>
<ul>
<li>将 <code>point</code> 添加到 <code>write request</code> 中：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut write_req = WriteRequest::default();
write_req.add_point(point);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>创建 <code>rpc_ctx</code>，同样地可以按需设置或者使用默认值，<code>rpc_ctx</code> 的详细信息请参考<a href="https://github.com/apache/incubator-horaedb-client-rs/blob/main/src/rpc_client/mod.rs#L23">这里</a>：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rpc_ctx = RpcContext {
    database: Some(&quot;public&quot;.to_string()),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<ul>
<li>最后，利用客户端写入数据到服务器：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rpc_ctx = RpcContext {
    database: Some(&quot;public&quot;.to_string()),
    ..Default::default()
};
let resp = client.write(rpc_ctx, &amp;write_req).await.expect(&quot;Should success to write&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="sql-query"><a class="header" href="#sql-query">Sql query</a></h2>
<p>我们支持使用 sql 进行数据查询。</p>
<ul>
<li>在 <code>sql query request</code> 中指定相关的表和 sql 语句：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let req = SqlQueryRequest {
    tables: vec![table name 1,...,table name n],
    sql: sql string (e.g. select * from xxx),
};
<span class="boring">}</span></code></pre></pre>
<ul>
<li>利用客户端进行查询：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = client.sql_query(rpc_ctx, &amp;req).await.expect(&quot;Should success to write&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="示例-2"><a class="header" href="#示例-2">示例</a></h2>
<p>你可以在本项目的仓库中找到<a href="https://github.com/apache/incubator-horaedb-client-rs/blob/main/examples/read_write.rs">完整的例子</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运维文档"><a class="header" href="#运维文档">运维文档</a></h1>
<p>本章介绍 HoraeDB 的运维相关的操作，包括表相关操作，设置访问黑名单，已经如何监控 HoraeDB。未来还会介绍集群扩容，容灾相关：</p>
<ul>
<li><a href="operation/./table.html">表</a></li>
<li><a href="operation/./system_table.html">系统表</a></li>
<li><a href="operation/./block_list.html">黑名单</a></li>
<li><a href="operation/./observability.html">监控</a></li>
<li><a href="operation/./cluster.html">集群运维</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表操作"><a class="header" href="#表操作">表操作</a></h1>
<p>HoraeDB 支持标准的 SQL，用户可以使用 Http 协议创建表和读写表。更多内容可以参考 <a href="operation/../sql/README.html">SQL 语法</a></p>
<h2 id="创建表-1"><a class="header" href="#创建表-1">创建表</a></h2>
<p>示例如下</p>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5000/sql' \
--header 'Content-Type: application/json' \
-d '{
    &quot;query&quot;: &quot;CREATE TABLE `demo` (`name` string TAG, `value` double NOT NULL, `t` timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE=Analytic with (enable_ttl='\''false'\'')&quot;
}'
</code></pre>
<h2 id="写数据-1"><a class="header" href="#写数据-1">写数据</a></h2>
<p>示例如下</p>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5000/sql' \
--header 'Content-Type: application/json' \
-d '{
    &quot;query&quot;: &quot;INSERT INTO demo(t, name, value) VALUES(1651737067000, '\''horaedb'\'', 100)&quot;
}'
</code></pre>
<h2 id="读数据"><a class="header" href="#读数据">读数据</a></h2>
<p>示例如下</p>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5000/sql' \
--header 'Content-Type: application/json' \
-d '{
    &quot;query&quot;: &quot;select * from demo&quot;
}'
</code></pre>
<h2 id="查询表信息"><a class="header" href="#查询表信息">查询表信息</a></h2>
<p>示例如下</p>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5000/sql' \
--header 'Content-Type: application/json' \
-d '{
    &quot;query&quot;: &quot;show create table demo&quot;
}'
</code></pre>
<h3 id="drop-表"><a class="header" href="#drop-表">Drop 表</a></h3>
<p>示例如下</p>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5000/sql' \
--header 'Content-Type: application/json' \
-d '{
    &quot;query&quot;: &quot;DROP TABLE demo&quot;
}'
</code></pre>
<h2 id="查询表路由"><a class="header" href="#查询表路由">查询表路由</a></h2>
<p>示例如下</p>
<pre><code class="language-shell">curl --location --request GET 'http://127.0.0.1:5000/route/{table_name}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统表"><a class="header" href="#系统表">系统表</a></h1>
<h2 id="查询-table-信息"><a class="header" href="#查询-table-信息">查询 Table 信息</a></h2>
<p>类似于 Mysql's <code>information_schema.tables</code>, HoraeDB 提供 <code>system.public.tables</code> 存储表信息。</p>
<p><code>system.public.tables</code> 表的列如下 :</p>
<ul>
<li>timestamp([TimeStamp])</li>
<li>catalog([String])</li>
<li>schema([String])</li>
<li>table_name([String])</li>
<li>table_id([Uint64])</li>
<li>engine([String])</li>
</ul>
<p>通过表名查询表信息示例如下：</p>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/sql' \
--header 'Content-Type: application/json' \
-d '{
    &quot;query&quot;: &quot;select * from system.public.tables where `table_name`=\&quot;my_table\&quot;&quot;
}'
</code></pre>
<p>返回结果</p>
<pre><code class="language-json">{
    &quot;rows&quot;:[
        {
            &quot;timestamp&quot;:0,
            &quot;catalog&quot;:&quot;horaedb&quot;,
            &quot;schema&quot;:&quot;public&quot;,
            &quot;table_name&quot;:&quot;my_table&quot;,
            &quot;table_id&quot;:3298534886446,
            &quot;engine&quot;:&quot;Analytic&quot;
        }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="黑名单"><a class="header" href="#黑名单">黑名单</a></h1>
<h2 id="增加黑名单"><a class="header" href="#增加黑名单">增加黑名单</a></h2>
<p>如果你想限制某个表的查询，可以把表名加到 <code>read_block_list</code> 中。</p>
<p>示例如下：</p>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/admin/block' \
--header 'Content-Type: application/json' \
-d '{
    &quot;operation&quot;:&quot;Add&quot;,
    &quot;write_block_list&quot;:[],
    &quot;read_block_list&quot;:[&quot;my_table&quot;]
}'
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;write_block_list&quot;: [],
  &quot;read_block_list&quot;: [&quot;my_table&quot;]
}
</code></pre>
<h2 id="设置黑名单"><a class="header" href="#设置黑名单">设置黑名单</a></h2>
<p>设置黑名单的操作首先会清理已有的列表，然后再把新的表设置进去。</p>
<p>示例如下：</p>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/admin/block' \
--header 'Content-Type: application/json' \
-d '{
    &quot;operation&quot;:&quot;Set&quot;,
    &quot;write_block_list&quot;:[],
    &quot;read_block_list&quot;:[&quot;my_table1&quot;,&quot;my_table2&quot;]
}'
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;write_block_list&quot;: [],
  &quot;read_block_list&quot;: [&quot;my_table1&quot;, &quot;my_table2&quot;]
}
</code></pre>
<h2 id="删除黑名单"><a class="header" href="#删除黑名单">删除黑名单</a></h2>
<p>如果你想把表从黑名单中移除，可以使用如下命令：</p>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/admin/block' \
--header 'Content-Type: application/json' \
-d '{
    &quot;operation&quot;:&quot;Remove&quot;,
    &quot;write_block_list&quot;:[],
    &quot;read_block_list&quot;:[&quot;my_table1&quot;]
}'
</code></pre>
<p>返回结果：</p>
<pre><code class="language-json">{
  &quot;write_block_list&quot;: [],
  &quot;read_block_list&quot;: [&quot;my_table2&quot;]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="监控"><a class="header" href="#监控">监控</a></h1>
<p>HoraeDB 支持使用 Prometheus 和 Grafana 做自监控。</p>
<h2 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h2>
<p><a href="https://github.com/prometheus/prometheus">Prometheus</a> 是非常流行的系统和服务监控系统。</p>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<p>把下面的配置保存到 <code>prometheus.yml</code> 文件中。比如，在 <code>tmp</code> 目录下，文件地址为 <code>/tmp/prometheus.yml</code>。</p>
<p>有两个 HoraeDB http 服务启动在 <code>localhost:5440</code>、<code>localhost:5441</code>。</p>
<pre><code class="language-yaml">global:
  scrape_interval: 30s
scrape_configs:
  - job_name: horaedb-server
    static_configs:
      - targets: [your_ip:5440, your_ip:5441]
        labels:
          env: horaedbcluster
</code></pre>
<p>Prometheus 详细配置见<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">这里</a>。</p>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<p>你可以使用 docker 来运行 Prometheus。Docker 镜像在<a href="https://hub.docker.com/r/prom/prometheus">这里</a>可以找到。</p>
<pre><code>docker run \
    -d --name=prometheus \
    -p 9090:9090 \
    -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml \
    prom/prometheus:v2.41.0
</code></pre>
<p>更多 Prometheus 安装方法，参考<a href="https://prometheus.io/docs/prometheus/latest/installation/">这里</a>。</p>
<h2 id="grafana"><a class="header" href="#grafana">Grafana</a></h2>
<p><a href="https://github.com/grafana/grafana">Grafana</a> 是一个非常流行的可观察性和数据可视化平台。</p>
<h3 id="运行-1"><a class="header" href="#运行-1">运行</a></h3>
<p>你可以使用 docker 来运行 Grafana。Docker 镜像在<a href="https://hub.docker.com/r/grafana/grafana">这里</a>可以找到。</p>
<pre><code>docker run -d --name=grafana -p 3000:3000 grafana/grafana:9.3.6
</code></pre>
<p>默认用户密码是 admin/admin.</p>
<p>运行上面命令后，grafana 可以用浏览器打开 http://127.0.0.1:3000。</p>
<p>更多 Prometheus 安装方法，参考<a href="https://grafana.com/docs/grafana/latest/setup-grafana/installation/">这里</a>。</p>
<h3 id="配置数据源"><a class="header" href="#配置数据源">配置数据源</a></h3>
<ol>
<li>将光标悬停在配置（齿轮）图标上。</li>
<li>选择数据源。</li>
<li>选择 Prometheus 数据源。</li>
</ol>
<p>注意: Prometheus 的 url 需要填写成这样 <code>http://your_ip:9090</code>, your_ip 换成本地地址。</p>
<img src="operation/../../resources/images/grafana-datasource.png" height="400" width="200"/>
<p>更详细的配置可以参考<a href="https://grafana.com/docs/grafana/latest/datasources/prometheus/">这里</a>。</p>
<h3 id="导入监控页面"><a class="header" href="#导入监控页面">导入监控页面</a></h3>
<p><a href="operation/../../resources/grafana-dashboard.json">页面 json</a></p>
<img src="operation/../../resources/images/grafana-dashboard.png" height="400" width="200"/>
<h2 id="horaedb-指标"><a class="header" href="#horaedb-指标">HoraeDB 指标</a></h2>
<p>当导入完成后，你可以看到如下页面：</p>
<img src="operation/../../resources/images/grafana-horaedb-dashboard.png" height="400" width="600"/>
<h3 id="panels"><a class="header" href="#panels">Panels</a></h3>
<ul>
<li>tps: 集群写入请求数。</li>
<li>qps: 集群查询请求数。</li>
<li>99th query/write duration: 查询写入的 99% 分位数。</li>
<li>table query by table: 表查询请求数。</li>
<li>99th write duration details by instance: 写入耗时的 99% 分位数。</li>
<li>99th query duration details by instance: 查询耗时的 99% 分位数。</li>
<li>99th write partition table duration: 分区表查询耗时的 99% 分位数。</li>
<li>table rows: 表的写入行数。</li>
<li>table rows by instance: 实例级别的写入行数。</li>
<li>total tables to write: 有数据写入的表数目。</li>
<li>flush count: HoraeDB flush 的次数。</li>
<li>99th flush duration details by instance: 实例级别的 flush 耗时的 99% 分位数。</li>
<li>99th write stall duration details by instance: 实例级别的写入停顿时间的 99% 分位数 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集群运维"><a class="header" href="#集群运维">集群运维</a></h1>
<p>集群运维接口的使用前提是，HoraeDB 部署为使用 HoraeMeta 的集群模式。</p>
<h2 id="运维接口"><a class="header" href="#运维接口">运维接口</a></h2>
<p>注意： 如下接口在实际使用时需要将 127.0.0.1 替换为 HoraeMeta 的真实地址。</p>
<ul>
<li>查询表元信息
当 tableNames 不为空的时候，使用 tableNames 进行查询。
当 tableNames 为空的时候，使用 ids 进行查询。使用 ids 查询的时候，schemaName 不生效。</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/table/query' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot;:&quot;defaultCluster&quot;,
    &quot;schemaName&quot;:&quot;public&quot;,
    &quot;names&quot;:[&quot;demo1&quot;, &quot;__demo1_0&quot;],
}'

curl --location 'http://127.0.0.1:8080/api/v1/table/query' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot;:&quot;defaultCluster&quot;,
    &quot;ids&quot;:[0, 1]
}'
</code></pre>
<ul>
<li>查询表的路由信息</li>
</ul>
<pre><code>curl --location --request POST 'http://127.0.0.1:8080/api/v1/route' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot;:&quot;defaultCluster&quot;,
    &quot;schemaName&quot;:&quot;public&quot;,
    &quot;table&quot;:[&quot;demo&quot;]
}'
</code></pre>
<ul>
<li>查询节点对应的 Shard 信息</li>
</ul>
<pre><code>curl --location --request POST 'http://127.0.0.1:8080/api/v1/getNodeShards' \
--header 'Content-Type: application/json' \
-d '{
    &quot;ClusterName&quot;:&quot;defaultCluster&quot;
}'
</code></pre>
<ul>
<li>查询 Shard 对应的表信息
如果 shardIDs 为空时，查询所有 shard 上表信息。</li>
</ul>
<pre><code>curl --location --request POST 'http://127.0.0.1:8080/api/v1/getShardTables' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot;:&quot;defaultCluster&quot;,
    &quot;shardIDs&quot;: [1,2]
}'
</code></pre>
<ul>
<li>删除指定表的元数据</li>
</ul>
<pre><code>curl --location --request POST 'http://127.0.0.1:8080/api/v1/dropTable' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot;: &quot;defaultCluster&quot;,
    &quot;schemaName&quot;: &quot;public&quot;,
    &quot;table&quot;: &quot;demo&quot;
}'
</code></pre>
<ul>
<li>Shard 切主</li>
</ul>
<pre><code>curl --location --request POST 'http://127.0.0.1:8080/api/v1/transferLeader' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot;:&quot;defaultCluster&quot;,
    &quot;shardID&quot;: 1,
    &quot;oldLeaderNodeName&quot;: &quot;127.0.0.1:8831&quot;,
    &quot;newLeaderNodeName&quot;: &quot;127.0.0.1:18831&quot;
}'
</code></pre>
<ul>
<li>Shard 分裂</li>
</ul>
<pre><code>curl --location --request POST 'http://127.0.0.1:8080/api/v1/split' \
--header 'Content-Type: application/json' \
-d '{
    &quot;clusterName&quot; : &quot;defaultCluster&quot;,
    &quot;schemaName&quot; :&quot;public&quot;,
    &quot;nodeName&quot; :&quot;127.0.0.1:8831&quot;,
    &quot;shardID&quot; : 0,
    &quot;splitTables&quot;:[&quot;demo&quot;]
}'
</code></pre>
<ul>
<li>创建 HoraeDB 集群</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/clusters' \
--header 'Content-Type: application/json' \
--data '{
    &quot;name&quot;:&quot;testCluster&quot;,
    &quot;nodeCount&quot;:3,
    &quot;ShardTotal&quot;:9,
    &quot;enableSchedule&quot;:true,
    &quot;topologyType&quot;:&quot;static&quot;
}'
</code></pre>
<ul>
<li>更新 HoraeDB 集群</li>
</ul>
<pre><code>curl --location --request PUT 'http://127.0.0.1:8080/api/v1/clusters/{NewClusterName}' \
--header 'Content-Type: application/json' \
--data '{
    &quot;nodeCount&quot;:28,
    &quot;shardTotal&quot;:128,
    &quot;enableSchedule&quot;:true,
    &quot;topologyType&quot;:&quot;dynamic&quot;
}'
</code></pre>
<ul>
<li>列出 HoraeDB 集群</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/clusters'
</code></pre>
<ul>
<li>修改 <code>enableSchedule</code></li>
</ul>
<pre><code>curl --location --request PUT 'http://127.0.0.1:8080/api/v1/clusters/{ClusterName}/enableSchedule' \
--header 'Content-Type: application/json' \
--data '{
    &quot;enable&quot;:true
}'
</code></pre>
<ul>
<li>查询 <code>enableSchedule</code></li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/clusters/{ClusterName}/enableSchedule'
</code></pre>
<ul>
<li>更新限流器</li>
</ul>
<pre><code>curl --location --request PUT 'http://127.0.0.1:8080/api/v1/flowLimiter' \
--header 'Content-Type: application/json' \
--data '{
    &quot;limit&quot;:1000,
    &quot;burst&quot;:10000,
    &quot;enable&quot;:true
}'
</code></pre>
<ul>
<li>查询限流器信息</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/flowLimiter'
</code></pre>
<ul>
<li>HoraeMeta 列出节点</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/etcd/member'
</code></pre>
<ul>
<li>HoraeMeta 节点切主</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/etcd/moveLeader' \
--header 'Content-Type: application/json' \
--data '{
    &quot;memberName&quot;:&quot;meta1&quot;
}'
</code></pre>
<ul>
<li>HoraeMeta 节点扩容</li>
</ul>
<pre><code>curl --location --request PUT 'http://127.0.0.1:8080/api/v1/etcd/member' \
--header 'Content-Type: application/json' \
--data '{
    &quot;memberAddrs&quot;:[&quot;http://127.0.0.1:42380&quot;]
}'
</code></pre>
<ul>
<li>HoraeMeta 替换节点</li>
</ul>
<pre><code>curl --location 'http://127.0.0.1:8080/api/v1/etcd/member' \
--header 'Content-Type: application/json' \
--data '{
    &quot;oldMemberName&quot;:&quot;meta0&quot;,
    &quot;newMemberAddr&quot;:[&quot;http://127.0.0.1:42380&quot;]
}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="周边生态"><a class="header" href="#周边生态">周边生态</a></h1>
<p>HoraeDB 是一个开放的系统，鼓励合作和创新，允许开发者使用最适合其自身需求的系统。目前 HoraeDB 支持以下系统：</p>
<ul>
<li><a href="ecosystem/prometheus.html">Prometheus</a></li>
<li><a href="ecosystem/influxdb.html">InfluxDB</a></li>
<li><a href="ecosystem/opentsdb.html">OpenTSDB</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prometheus-1"><a class="header" href="#prometheus-1">Prometheus</a></h1>
<p><a href="https://prometheus.io/">Prometheus</a>是一个流行的云原生监控工具，由于其可扩展性、可靠性和可伸缩性，被企业广泛采用。它用于从云原生服务（如 Kubernetes 和 OpenShift）中获取指标，并将其存储在时序数据库中。Prometheus 也很容易扩展，允许用户用其他数据库扩展其特性和功能。</p>
<p>HoraeDB 可以作为 Prometheus 的长期存储解决方案，同时支持远程读取和远程写入 API。</p>
<h2 id="配置-1"><a class="header" href="#配置-1">配置</a></h2>
<p>你可以通过在<code>prometheus.yml</code>中添加以下几行来配置 Prometheus 使用 HoraeDB 作为一个远程存储：</p>
<pre><code class="language-yml">remote_write:
  - url: &quot;http://&lt;address&gt;:&lt;http_port&gt;/prom/v1/write&quot;
remote_read:
  - url: &quot;http://&lt;address&gt;:&lt;http_port&gt;/prom/v1/read&quot;
</code></pre>
<p>每一个指标都会对应一个 HoraeDB 中的表：</p>
<ul>
<li>标签（labels）对应字符串类型的 <code>tag</code> 列</li>
<li>数据的时间戳对应一个 timestamp 类型的 <code>timestmap</code> 列</li>
<li>数据的值对应一个双精度浮点数类型的 <code>value</code> 列</li>
</ul>
<p>比如有如下 Prometheus 指标：</p>
<pre><code>up{env=&quot;dev&quot;, instance=&quot;127.0.0.1:9090&quot;, job=&quot;prometheus-server&quot;}
</code></pre>
<p>对应 HoraeDB 中如下的表(注意：创建表的 TTL 是 7d，写入超过当前周期数据会被丢弃)：</p>
<pre><code>CREATE TABLE `up` (
    `timestamp` timestamp NOT NULL,
    `tsid` uint64 NOT NULL,
    `env` string TAG,
    `instance` string TAG,
    `job` string TAG,
    `value` double,
    PRIMARY KEY (tsid, timestamp),
    timestamp KEY (timestamp)
);

SELECT * FROM up;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">tsid</th><th style="text-align: center">timestamp</th><th style="text-align: center">env</th><th style="text-align: center">instance</th><th style="text-align: center">job</th><th style="text-align: center">value</th></tr></thead><tbody>
<tr><td style="text-align: center">12683162471309663278</td><td style="text-align: center">1675824740880</td><td style="text-align: center">dev</td><td style="text-align: center">127.0.0.1:9090</td><td style="text-align: center">prometheus-server</td><td style="text-align: center">1</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="influxdb"><a class="header" href="#influxdb">InfluxDB</a></h1>
<p><a href="https://www.influxdata.com/products/influxdb-overview/">InfluxDB</a> 是一个时间序列数据库，旨在处理高写入和查询负载。它是 TICK 堆栈的一个组成部分。InfluxDB 旨在用作涉及大量时间戳数据的任何用例的后备存储，包括 DevOps 监控、应用程序指标、物联网传感器数据和实时分析。</p>
<p>HoraeDB 支持 <a href="https://docs.influxdata.com/influxdb/v1.8/tools/api/#influxdb-1x-http-endpoints">InfluxDB v1.8</a> 写入和查询 API。</p>
<blockquote>
<p>注意：用户需要将以下配置添加到服务器的配置中才能尝试 InfluxDB 写入/查询。</p>
</blockquote>
<pre><code>[server.default_schema_config]
default_timestamp_column_name = &quot;time&quot;
</code></pre>
<h1 id="写入"><a class="header" href="#写入">写入</a></h1>
<pre><code>curl -i -XPOST &quot;http://localhost:5440/influxdb/v1/write&quot; --data-binary '
demo,tag1=t1,tag2=t2 field1=90,field2=100 1679994647000
demo,tag1=t1,tag2=t2 field1=91,field2=101 1679994648000
demo,tag1=t11,tag2=t22 field1=90,field2=100 1679994647000
demo,tag1=t11,tag2=t22 field1=91,field2=101 1679994648000
'
</code></pre>
<p>Post 的内容采用的是 <a href="https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_reference/">InfluxDB line protocol</a> 格式。</p>
<p><code>measurement</code> 将映射到 HoraeDB 中的一个表，在首次写入时 server 会自动进行建表(注意：创建表的 TTL 是 7d，写入超过当前周期数据会被丢弃)。</p>
<p>例如，在上面插入数据时，HoraeDB 中将创建下表：</p>
<pre><code>CREATE TABLE `demo` (
    `tsid` uint64 NOT NULL,
    `time` timestamp NOT NULL,
    `field1` double,
    `field2` double,
    `tag1` string TAG,
    `tag2` string TAG,
    PRIMARY KEY (tsid, time),
    timestamp KEY (time))
</code></pre>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<ul>
<li>InfluxDB 在写入时，时间戳精度默认是纳秒，HoraeDB 只支持毫秒级时间戳，用户可以通过 <code>precision</code> 参数指定数据精度，HoraeDB 内部会自动转成毫秒精度。</li>
<li>暂时不支持诸如 <code>db</code> 等查询参数</li>
</ul>
<h1 id="查询-1"><a class="header" href="#查询-1">查询</a></h1>
<pre><code class="language-sh"> curl -G 'http://localhost:5440/influxdb/v1/query' --data-urlencode 'q=SELECT * FROM &quot;demo&quot;'
</code></pre>
<p>查询结果和 InfluxDB 查询接口一致：</p>
<pre><code class="language-json">{
  &quot;results&quot;: [
    {
      &quot;statement_id&quot;: 0,
      &quot;series&quot;: [
        {
          &quot;name&quot;: &quot;demo&quot;,
          &quot;columns&quot;: [&quot;time&quot;, &quot;field1&quot;, &quot;field2&quot;, &quot;tag1&quot;, &quot;tag2&quot;],
          &quot;values&quot;: [
            [1679994647000, 90.0, 100.0, &quot;t1&quot;, &quot;t2&quot;],
            [1679994647000, 90.0, 100.0, &quot;t11&quot;, &quot;t22&quot;],
            [1679994648000, 91.0, 101.0, &quot;t1&quot;, &quot;t2&quot;],
            [1679994648000, 91.0, 101.0, &quot;t11&quot;, &quot;t22&quot;]
          ]
        }
      ]
    }
  ]
}
</code></pre>
<h2 id="如何在-grafana-中使用"><a class="header" href="#如何在-grafana-中使用">如何在 Grafana 中使用</a></h2>
<p>HoraeDB 可以用作 Grafana 中的 InfluxDB 数据源。具体方式如下：</p>
<ul>
<li>在新增数据源时，选择 InfluxDB 类型</li>
<li>在 HTTP URL 处，输入 <code>http://{ip}:{5440}/influxdb/v1/</code> 。对于本地部署的场景，可以直接输入 http://localhost:5440/influxdb/v1/</li>
<li><code>Save &amp; test</code></li>
</ul>
<h2 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h2>
<p>暂时不支持诸如 <code>epoch</code>, <code>db</code> 等的查询参数</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opentsdb"><a class="header" href="#opentsdb">OpenTSDB</a></h1>
<p><a href="http://opentsdb.net/">OpenTSDB</a> 是基于 HBase 的分布式、可伸缩的时间序列数据库。</p>
<h1 id="写入-1"><a class="header" href="#写入-1">写入</a></h1>
<p>HoraeDB 遵循 <a href="http://opentsdb.net/docs/build/html/api_http/put.html">OpenTSDB put</a> 写入接口。</p>
<p><code>summary</code> 和 <code>detailed</code> 还未支持。</p>
<pre><code>curl --location 'http://localhost:5440/opentsdb/api/put' \
--header 'Content-Type: application/json' \
-d '[{
    &quot;metric&quot;: &quot;sys.cpu.nice&quot;,
    &quot;timestamp&quot;: 1692588459000,
    &quot;value&quot;: 18,
    &quot;tags&quot;: {
       &quot;host&quot;: &quot;web01&quot;,
       &quot;dc&quot;: &quot;lga&quot;
    }
},
{
    &quot;metric&quot;: &quot;sys.cpu.nice&quot;,
    &quot;timestamp&quot;: 1692588459000,
    &quot;value&quot;: 18,
    &quot;tags&quot;: {
       &quot;host&quot;: &quot;web01&quot;
    }
}]'
</code></pre>
<p><code>metric</code> 将映射到 HoraeDB 中的一个表，在首次写入时 server 会自动进行建表(注意：创建表的 TTL 是 7d，写入超过当前周期数据会被丢弃)。</p>
<p>例如，在上面插入数据时，HoraeDB 中将创建下表：</p>
<pre><code>CREATE TABLE `sys.cpu.nice`(
    `tsid` uint64 NOT NULL,
    `timestamp` timestamp NOT NULL,
    `dc` string TAG,
    `host` string TAG,
    `value` bigint,
    PRIMARY KEY(tsid, timestamp),
    TIMESTAMP KEY(timestamp))
    ENGINE = Analytic
    WITH(arena_block_size = '2097152', compaction_strategy = 'default',
    compression = 'ZSTD', enable_ttl = 'true', num_rows_per_row_group = '8192',
    segment_duration = '2h', storage_format = 'AUTO', ttl = '7d',
    update_mode = 'OVERWRITE', write_buffer_size = '33554432')
</code></pre>
<h1 id="查询-2"><a class="header" href="#查询-2">查询</a></h1>
<p>暂不支持 OpenTSDB 查询，<a href="https://github.com/apache/incubator-horaedb/issues/904">tracking issue</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">target</th><th style="text-align: center">OS</th><th style="text-align: center">status</th></tr></thead><tbody>
<tr><td style="text-align: center">x86_64-unknown-linux-gnu</td><td style="text-align: center">kernel 4.9+</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">x86_64-apple-darwin</td><td style="text-align: center">10.15+, Catalina+</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">aarch64-apple-darwin</td><td style="text-align: center">11+, Big Sur+</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">aarch64-unknown-linux-gnu</td><td style="text-align: center">TBD</td><td style="text-align: center">tracked on <a href="https://github.com/apache/incubator-horaedb/issues/63">#63</a></td></tr>
<tr><td style="text-align: center">*-windows</td><td style="text-align: center">*</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p>为了编译 HoraeDB, 首先需要安装相关的依赖（包括 <code>Rust</code> 的工具链)。</p>
<h1 id="依赖ubuntu2004"><a class="header" href="#依赖ubuntu2004">依赖(Ubuntu20.04)</a></h1>
<p>假设我们的开发环境是 Ubuntu20.04, 可以执行如下命令来安装所需的依赖。</p>
<pre><code class="language-shell">sudo apt install git curl gcc g++ libssl-dev pkg-config cmake protobuf-compiler
</code></pre>
<p>需要注意的是，项目的编译对 cmake、gcc、g++等依赖项有版本要求。</p>
<p>如果你的开发环境是旧的 Linux 发行版，有必要手动安装这些依赖项的高版本。</p>
<h1 id="依赖macos"><a class="header" href="#依赖macos">依赖(MacOS)</a></h1>
<p>如果你的开发环境是 <code>MacOS</code> ，可以使用如下命令手动安装这些依赖项的高版本。</p>
<ol>
<li>安装命令行工具：</li>
</ol>
<pre><code class="language-shell">xcode-select --install
</code></pre>
<ol start="2">
<li>安装 cmake:</li>
</ol>
<pre><code class="language-shell">brew install cmake
</code></pre>
<ol start="3">
<li>安装 protobuf:</li>
</ol>
<pre><code class="language-shell">brew install protobuf
</code></pre>
<h1 id="rust-1"><a class="header" href="#rust-1">Rust</a></h1>
<p><code>Rust</code> 可以使用 <a href="https://rustup.rs/">rustup</a> 来安装。
安装 <code>Rust</code> 后，进入 HoraeDB 工程目录，根据工具链文件指定的 <code>Rust</code> 版本会被自动下载。</p>
<p>执行后，你需要添加环境变量来使用 <code>Rust</code> 工具链。只要把下面的命令放到你的<code>~/.bashrc</code>或<code>~/.bash_profile</code>中即可。</p>
<pre><code class="language-shell">source $HOME/.cargo/env
</code></pre>
<h1 id="编译运行"><a class="header" href="#编译运行">编译运行</a></h1>
<p>注意：gcc 版本要求是 8, 更高的版本可能出现编译报错。该问题在 <a href="https://github.com/apache/incubator-horaedb/issues/1506">issue-1506</a> 中跟进。</p>
<p>编译 HoraeDB 命令如下:</p>
<pre><code>cargo build --release
</code></pre>
<p>然后可以使用特定的配置文件运行 HoraeDB。</p>
<pre><code class="language-bash">./target/release/horaedb-server --config ./docs/minimal.toml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="剖析"><a class="header" href="#剖析">剖析</a></h2>
<h3 id="cpu-剖析"><a class="header" href="#cpu-剖析">CPU 剖析</a></h3>
<p>HoraeDB 提供 CPU 剖析 http 接口 <code>debug/profile/cpu</code>.</p>
<p>例子:</p>
<pre><code>// 60s CPU 采样数据
curl 0:5000/debug/profile/cpu/60

// 产出文件
/tmp/flamegraph_cpu.svg
</code></pre>
<h3 id="内存剖析"><a class="header" href="#内存剖析">内存剖析</a></h3>
<p>HoraeDB 提供内存剖析 http 接口 <code>debug/profile/heap</code>.</p>
<h3 id="安装依赖"><a class="header" href="#安装依赖">安装依赖</a></h3>
<pre><code>sudo yum install -y jemalloc-devel ghostscript graphviz
</code></pre>
<p>例子:</p>
<pre><code>// 开启 malloc prof
export MALLOC_CONF=prof:true

// 运行 horaedb-server
./horaedb-server ....

// 60s 内存采样数据
curl -L '0:5000/debug/profile/heap/60' &gt; /tmp/heap_profile
jeprof --show_bytes --pdf /usr/bin/horaedb-server /tmp/heap_profile &gt; profile_heap.pdf

jeprof --show_bytes --svg /usr/bin/horaedb-server /tmp/heap_profile &gt; profile_heap.svg
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发规约"><a class="header" href="#开发规约">开发规约</a></h1>
<p>开发规约请参考英文版本<a href="dev/../../en/dev/conventional_commit.html">文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="风格规范"><a class="header" href="#风格规范">风格规范</a></h1>
<p>风格规范请参考英文版本<a href="dev/../../en/dev/style_guide.html">文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="roadmap"><a class="header" href="#roadmap">RoadMap</a></h2>
<h3 id="v010"><a class="header" href="#v010">v0.1.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
支持基于本地磁盘的 Standalone 版本</li>
<li><input disabled="" type="checkbox" checked=""/>
支持分析存储格式</li>
<li><input disabled="" type="checkbox" checked=""/>
支持 SQL</li>
</ul>
<h3 id="v020"><a class="header" href="#v020">v0.2.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
静态路由的分布式版本</li>
<li><input disabled="" type="checkbox" checked=""/>
远端存储支持阿里云 OSS</li>
<li><input disabled="" type="checkbox" checked=""/>
支持基于 <a href="https://github.com/oceanbase/oceanbase">OBKV</a>的 WAL</li>
</ul>
<h3 id="v030"><a class="header" href="#v030">v0.3.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
发布多语言客户端，包括 Java, Rust 和 Python</li>
<li><input disabled="" type="checkbox" checked=""/>
支持使用 <code>HoraeMeta</code> 的静态集群</li>
<li><input disabled="" type="checkbox" checked=""/>
混合存储格式基本实现</li>
</ul>
<h3 id="v040"><a class="header" href="#v040">v0.4.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
实现更复杂的集群方案，增强 HoraeDB 的可靠性和可扩展性</li>
<li><input disabled="" type="checkbox" checked=""/>
构建日常运行的、基于 TSBS 的压测任务</li>
</ul>
<h3 id="v100-alpha-released"><a class="header" href="#v100-alpha-released">v1.0.0-alpha (Released)</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
基于 <code>Apache Kafka</code> 实现分布式 WAL</li>
<li><input disabled="" type="checkbox" checked=""/>
发布 Golang 客户端</li>
<li><input disabled="" type="checkbox" checked=""/>
优化时序场景下的查询性能</li>
<li><input disabled="" type="checkbox" checked=""/>
支持集群模式下表的动态转移</li>
</ul>
<h3 id="v100"><a class="header" href="#v100">v1.0.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
正式发布 HoraeDB 和相关 SDK，并完成所有的 breaking changes</li>
<li><input disabled="" type="checkbox" checked=""/>
完成分区表的主要工作</li>
<li><input disabled="" type="checkbox" checked=""/>
优化查询性能，特别是云原生集群模式下，包括：
<ul>
<li>多级缓存</li>
<li>多种方式减少从远端获取的数据量(提高 SST 数据过滤精度)</li>
<li>提高获取远程对象存储数据的并发度</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
通过控制合并时的资源消耗，提高数据写入性能</li>
</ul>
<h3 id="afterwards"><a class="header" href="#afterwards">Afterwards</a></h3>
<p>随着对时序数据库及其各种使用情况的深入了解，我们的大部分工作将聚焦在性能、可靠性、可扩展性、易用性以及与开源社区的合作方面</p>
<ul>
<li><input disabled="" type="checkbox"/>
增加支持 <code>PromQL</code>, <code>InfluxQL</code>, <code>OpenTSDB</code> 协议</li>
<li><input disabled="" type="checkbox"/>
提供基础的运维工具。特别包括如下：
<ul>
<li>适配云基础设施的部署工具，如 <code>Kubernetes</code></li>
<li>加强自监控能力，特别是关键的日志和指标</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
开发多种工具，方便使用 HoraeDB，例如，数据导入和导出工具</li>
<li><input disabled="" type="checkbox"/>
探索新的存储格式，提高混合负载（分析和时序负载）的性能</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="horaedb-架构介绍"><a class="header" href="#horaedb-架构介绍">HoraeDB 架构介绍</a></h1>
<h2 id="本文目标"><a class="header" href="#本文目标">本文目标</a></h2>
<ul>
<li>为想了解更多关于 HoraeDB 但不知道从何入手的开发者提供 HoraeDB 的概览</li>
<li>简要介绍 HoraeDB 的主要模块以及这些模块之间的联系，但不涉及它们实现的细节</li>
</ul>
<h2 id="动机"><a class="header" href="#动机">动机</a></h2>
<p>HoraeDB 是一个时序数据库，与经典时序数据库相比，HoraeDB 的目标是能够同时处理时序型和分析型两种模式的数据，并提供高效的读写。</p>
<p>在经典的时序数据库中，<code>Tag</code> 列（ <code>InfluxDB</code> 称之为 <code>Tag</code>，<code>Prometheus</code> 称之为 <code>Label</code>）通常会对其生成倒排索引，但在实际使用中，<code>Tag</code> 的基数在不同的场景中是不一样的 ———— 在某些场景下，<code>Tag</code> 的基数非常高（这种场景下的数据，我们称之为分析型数据），而基于倒排索引的读写要为此付出很高的代价。而另一方面，分析型数据库常用的扫描 + 剪枝方法，可以比较高效地处理这样的分析型数据。</p>
<p>因此 HoraeDB 的基本设计理念是采用混合存储格式和相应的查询方法，从而达到能够同时高效处理时序型数据和分析型数据。</p>
<h2 id="架构"><a class="header" href="#架构">架构</a></h2>
<pre><code class="language-plaintext">┌──────────────────────────────────────────┐
│       RPC Layer (HTTP/gRPC/MySQL)        │
└──────────────────────────────────────────┘
┌──────────────────────────────────────────┐
│                 SQL Layer                │
│ ┌─────────────────┐  ┌─────────────────┐ │
│ │     Parser      │  │     Planner     │ │
│ └─────────────────┘  └─────────────────┘ │
└──────────────────────────────────────────┘
┌───────────────────┐  ┌───────────────────┐
│    Interpreter    │  │      Catalog      │
└───────────────────┘  └───────────────────┘
┌──────────────────────────────────────────┐
│               Query Engine               │
│ ┌─────────────────┐  ┌─────────────────┐ │
│ │    Optimizer    │  │    Executor     │ │
│ └─────────────────┘  └─────────────────┘ │
└──────────────────────────────────────────┘
┌──────────────────────────────────────────┐
│         Pluggable Table Engine           │
│  ┌────────────────────────────────────┐  │
│  │              Analytic              │  │
│  │┌────────────────┐┌────────────────┐│  │
│  ││      Wal       ││    Memtable    ││  │
│  │└────────────────┘└────────────────┘│  │
│  │┌────────────────┐┌────────────────┐│  │
│  ││     Flush      ││   Compaction   ││  │
│  │└────────────────┘└────────────────┘│  │
│  │┌────────────────┐┌────────────────┐│  │
│  ││    Manifest    ││  Object Store  ││  │
│  │└────────────────┘└────────────────┘│  │
│  └────────────────────────────────────┘  │
│  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │
│           Another Table Engine        │  │
│  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │
└──────────────────────────────────────────┘
</code></pre>
<p>上图展示了 HoraeDB 单机版本的架构，下面将会介绍重要模块的细节。</p>
<h3 id="rpc-层"><a class="header" href="#rpc-层">RPC 层</a></h3>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/server</p>
<p>当前的 RPC 支持多种协议，包括 HTTP、gRPC、MySQL。</p>
<p>通常 HTTP 和 MySQL 用于调试 HoraeDB，手动查询和执行 DDL 操作（如创建、删除表等）。而 gRPC 协议可以被看作是一种用于高性能的定制协议，更适用于大量的读写操作。</p>
<h3 id="sql-层"><a class="header" href="#sql-层">SQL 层</a></h3>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/query_frontend</p>
<p>SQL 层负责解析 SQL 并生成查询计划。</p>
<p>HoraeDB 基于 <a href="https://github.com/sqlparser-rs/sqlparser-rs">sqlparser</a> 提供了一种 SQL 方言，为了更好的适配时序数据，引入一些概念，包括 Tag 和 Timestamp。此外，利用 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a>，HoraeDB 不仅可以生成常规的逻辑计划，还可以生成自定义的计划来实现时序场景要求的特殊算子，例如为了适配 PromQL 协议而做的工作就是利用了这个特性。</p>
<h3 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h3>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/interpreters</p>
<p><code>Interpreter</code> 模块封装了 SQL 的 <code>CRUD</code> 操作。在查询流程中，一个 SQL 语句会经过解析，生成出对应的查询计划，然后便会在特定的解释器中执行，例如 <code>SelectInterpreter</code>、<code>InsertInterpreter</code> 等。</p>
<h3 id="catalog"><a class="header" href="#catalog">Catalog</a></h3>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/catalog_impls</p>
<p><code>Catalog</code> 实际上是管理元数据的模块，HoraeDB 采用的元数据分级与 PostgreSQL 类似：<code>Catalog &gt; Schema &gt; Table</code>，但目前它们只用作命名空间。</p>
<p>目前，<code>Catalog</code> 和 <code>Schema</code> 在单机模式和分布式模式存在两种不同实现，因为一些生成 id 和持久化元数据的策略在这两种模式下有所不同。</p>
<h3 id="查询引擎"><a class="header" href="#查询引擎">查询引擎</a></h3>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/query_engine</p>
<p>查询引擎负责优化和执行由 SQL 层解析出来的 SQL 计划，目前查询引擎实际上基于 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 来实现的。</p>
<p>除了 SQL 的基本功能外，HoraeDB 还通过利用 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 提供的扩展接口，为某些特定的查询（比如 <code>PromQL</code>）构建了一些定制的查询协议和优化规则。</p>
<h3 id="pluggable-table-engine"><a class="header" href="#pluggable-table-engine">Pluggable Table Engine</a></h3>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/table_engine</p>
<p><code>Table Engine</code> 是 HoraeDB 中用于管理表的存储引擎，其可插拔性是 HoraeDB 的一个核心设计，对于实现我们的一些长远目标（比如增加 Log 或 Tracing 类型数据的存储引擎）至关重要。HoraeDB 将会有多种 <code>Table Engine</code> 用于不同的工作负载，根据工作负载模式，应该选择最合适的存储引擎。</p>
<p>现在对 Table Engine 的要求是：</p>
<ul>
<li>管理引擎下的所有共享资源：
<ul>
<li>内存</li>
<li>存储</li>
<li>CPU</li>
</ul>
</li>
<li>管理表的元数据，如表的结构、表的参数选项；</li>
<li>能够提供 <code>Table</code> 实例，该实例可以提供 <code>read</code> 和 <code>write</code> 的能力；</li>
<li>负责 <code>Table</code> 实例的创建、打开、删除和关闭；</li>
<li>....</li>
</ul>
<p>实际上，<code>Table Engine</code> 需要处理的事情有点复杂。现在在 HoraeDB 中，只提供了一个名为 <code>Analytic</code> 的 <code>Table Engine</code>，它在处理分析工作负载方面做得很好，但是在时序工作负载上还有很大的进步空间（我们计划通过添加一些帮助处理时序工作负载的索引来提高性能）。</p>
<p>以下部分描述了 <code>Analytic Table Engine</code> 的详细信息。</p>
<h4 id="wal"><a class="header" href="#wal">WAL</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/wal</p>
<p>HoraeDB 处理数据的模型是 <code>WAL</code> + <code>MemTable</code>，最近写入的数据首先被写入 <code>WAL</code>，然后写入 <code>MemTable</code>，在 <code>MemTable</code> 中累积了一定数量的数据后，该数据将以便于查询的形式被重新构建，并存储到持久化设备上。</p>
<p>目前，为 <code>standalone</code> 模式和分布式模式提供了三种 <code>WAL</code> 实现：</p>
<ul>
<li>对于 <code>standalone</code> 模式，<code>WAL</code> 基于 <code>RocksDB</code>，数据存储在本地磁盘上。</li>
<li>对于分布式模式，需要 <code>WAL</code> 作为一个分布式组件，负责新写入数据的可靠性，因此，我们现在提供了基于 <a href="https://github.com/oceanbase/oceanbase"><code>OceanBase</code></a> 的实现。</li>
<li>对于分布式模式，除了 <a href="https://github.com/oceanbase/oceanbase"><code>OceanBase</code></a>，我们还提供了一个更轻量级的基于 <a href="https://github.com/apache/kafka"><code>Apache Kafka</code></a> 实现。</li>
</ul>
<h4 id="memtable"><a class="header" href="#memtable">MemTable</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/analytic_engine/src/memtable</p>
<p>由于 <code>WAL</code> 无法提供高效的查询，因此新写入的数据会存储一份到 <code>Memtable</code> 用于查询，并且在积累了一定数量后，HoraeDB 将 <code>MemTable</code> 中的数据组织成便于查询的存储格式（<code>SST</code>）并存储到持久化设备中。</p>
<p>MemTable 的当前实现基于 <a href="https://github.com/tikv/agatedb/blob/8510bff2bfde5b766c3f83cf81c00141967d48a4/skiplist">agatedb 的 skiplist</a>。它允许并发读取和写入，并且可以根据 <a href="https://github.com/apache/incubator-horaedb/tree/main/components/skiplist">Arena</a> 控制内存使用。</p>
<h4 id="flush"><a class="header" href="#flush">Flush</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/blob/main/analytic_engine/src/instance/flush_compaction.rs</p>
<p>当 <code>MemTable</code> 的内存使用量达到阈值时，<code>Flush</code> 操作会选择一些老的 <code>MemTable</code>，将其中的数据组织成便于查询的 <code>SST</code> 存储到持久化设备上。</p>
<p>在刷新过程中，数据将按照一定的时间段（由表选项 <code>Segment Duration</code> 配置）进行划分，保证任何一个 <code>SST</code> 的所有数据的时间戳都属于同一个 <code>Segment</code>。实际上，这也是大多数时序数据库中常见的操作，按照时间维度组织数据，以加速后续的时间相关操作，如查询一段时间内的数据，清除超出 <code>TTL</code> 的数据等。</p>
<h4 id="compaction"><a class="header" href="#compaction">Compaction</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/analytic_engine/src/compaction</p>
<p><code>MemTable</code> 的数据被刷新为 <code>SST</code> 文件，但最近刷新的 <code>SST</code> 文件可能非常小，而过小或过多的 <code>SST</code> 文件会导致查询性能不佳，因此，引入 <code>Compaction</code> 来重新整理 SST 文件，使多个较小的 <code>SST</code> 文件可以合并成较大的 <code>SST</code> 文件。</p>
<h4 id="manifest"><a class="header" href="#manifest">Manifest</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/analytic_engine/src/meta</p>
<p><code>Manifest</code> 负责管理每个表的元数据，包括：</p>
<ul>
<li>表的结构和表的参数选项；</li>
<li>最新 <code>Flush</code> 过的 sequence number；</li>
<li>表的所有 <code>SST</code> 文件的信息。</li>
</ul>
<p>现在 <code>Manifest</code> 是基于 <code>WAL</code> 和 <code>Object Store</code> 来实现的，新的改动会直接写入到 <code>WAL</code>，而为了避免元数据无限增长（实际上每次 <code>Flush</code> 操作都会触发更新），会对其写入的记录做快照，生成的快照会被持久化道 <code>Object Store</code>。</p>
<h4 id="object-storage-1"><a class="header" href="#object-storage-1">Object Storage</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/components/object_store</p>
<p><code>Flush</code> 操作产生的 <code>SST</code> 文件需要持久化存储，而用于抽象持久化存储设备的就是 <code>Object Storage</code>，其中包括多种实现：</p>
<ul>
<li>基于本地文件系统；</li>
<li>基于<a href="https://www.alibabacloud.com/product/object-storage-service">阿里云 OSS</a>。</li>
</ul>
<p>HoraeDB 的分布式架构的一个核心特性就是存储和计算分离，因此要求 <code>Object Storage</code> 是一个高可用的服务，并独立于 HoraeDB。因此，像<a href="https://aws.amazon.com/s3/">Amazon S3</a>、<a href="https://www.alibabacloud.com/product/object-storage-service">阿里云 OSS</a>等存储系统是不错的选择，未来还将计划实现在其他云服务提供商的存储系统上。</p>
<h4 id="sst"><a class="header" href="#sst">SST</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/tree/main/analytic_engine/src/sst</p>
<p><code>SST</code> 本身实际上是一种抽象，可以有多种具体实现。目前的实现是基于 <a href="https://parquet.apache.org/">Parquet</a>，它是一种面向列的数据文件格式，旨在实现高效的数据存储和检索。</p>
<p><code>SST</code> 的格式对于数据检索非常关键，也是决定查询性能的关键所在。目前，我们基于 <a href="https://parquet.apache.org/">Parquet</a> 的 <code>SST</code> 实现在处理分析型数据时表现良好，但目前在处理时序型数据上还有较高的提升空间。在我们的路线图中，我们将探索更多的存储格式，以便在两种类型的数据处理上都取得良好的性能。</p>
<h4 id="space"><a class="header" href="#space">Space</a></h4>
<p>模块路径：https://github.com/apache/incubator-horaedb/blob/main/analytic_engine/src/space.rs</p>
<p>在 <code>Analytic Engine</code> 中，有一个叫做 <code>space</code> 的概念，这里着重解释一下，以解决阅读源代码时出现的一些歧义。
实际上，<code>Analytic Engine</code> 没有 <code>catalog</code> 和 <code>schema</code> 的概念，只提供两个层级的关系：<code>space</code> 和 <code>table</code>。在实现中，上层的 <code>schema id</code>（要求在所有的 <code>catalogs</code> 中都应该是唯一的）实际上会直接映射成 <code>space id</code>。</p>
<p><code>Analytic Engine</code> 中的 <code>space</code> 主要用于隔离不同租户的资源，如内存的使用。</p>
<h2 id="critical-path"><a class="header" href="#critical-path">Critical Path</a></h2>
<p>简要介绍了 HoraeDB 的一些重要模块后，我们将对代码中的一些关键路径进行描述，希望为有兴趣的开发人员在阅读代码时提供一些帮助。</p>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<pre><code class="language-plaintext">┌───────┐      ┌───────┐      ┌───────┐
│       │──1──▶│       │──2──▶│       │
│Server │      │  SQL  │      │Catalog│
│       │◀─10──│       │◀─3───│       │
└───────┘      └───────┘      └───────┘
                │    ▲
               4│   9│
                │    │
                ▼    │
┌─────────────────────────────────────┐
│                                     │
│             Interpreter             │
│                                     │
└─────────────────────────────────────┘
                           │    ▲
                          5│   8│
                           │    │
                           ▼    │
                   ┌──────────────────┐
                   │                  │
                   │   Query Engine   │
                   │                  │
                   └──────────────────┘
                           │    ▲
                          6│   7│
                           │    │
                           ▼    │
 ┌─────────────────────────────────────┐
 │                                     │
 │            Table Engine             │
 │                                     │
 └─────────────────────────────────────┘
</code></pre>
<p>以 <code>SELECT</code> SQL 为例，上图展示了查询过程，其中的数字表示模块之间调用的顺序。</p>
<p>以下是详细流程：</p>
<ul>
<li>Server 模块根据请求使用的协议选择合适的 rpc 模块（可能是 HTTP、gRPC 或 mysql）来处理请求；</li>
<li>使用 parser 解析请求中的 sql ；</li>
<li>根据解析好的 sql 以及 catalog/schema 提供的元信息，通过 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 可以生成逻辑计划；</li>
<li>根据逻辑计划创建相应的 <code>Interpreter</code>，并由其执行逻辑计划；</li>
<li>对于正常 <code>SELECT</code> SQL 的逻辑计划，它将通过 <code>SelectInterpreter</code> 执行；</li>
<li>在 <code>SelectInterpreter</code> 中，特定的查询逻辑由 <code>Query Engine</code> 执行：
<ul>
<li>优化逻辑计划；</li>
<li>生成物理计划；</li>
<li>优化物理计划；</li>
<li>执行物理计划；</li>
</ul>
</li>
<li>执行物理计划涉及到 <code>Analytic Engine</code>：
<ul>
<li>通过 <code>Analytic Engine</code> 提供的 <code>Table</code> 实例的 <code>read</code> 方法获取数据；</li>
<li>表数据的来源是 <code>SST</code> 和 <code>Memtable</code>，可以通过谓词下推进行提前过滤；</li>
<li>在检索到表数据后，<code>Query Engine</code> 将完成具体计算并生成最终结果；</li>
</ul>
</li>
<li><code>SelectInterpreter</code> 获取结果并将其传输给 Protocol 模块；</li>
<li>协议模块完成转换结果后，Server 模块将其响应给客户端。</li>
</ul>
<p>以下是<a href="https://github.com/apache/incubator-horaedb/releases/tag/v1.2.2">v1.2.2</a>的函数调用流程:</p>
<pre><code>                                                       ┌───────────────────────◀─────────────┐    ┌───────────────────────┐
                                                       │      handle_sql       │────────┐    │    │       parse_sql       │
                                                       └───────────────────────┘        │    │    └────────────────┬──────┘
                                                           │             ▲              │    │           ▲         │
                                                           │             │              │    │           │         │
                                                           │             │              │    └36───┐     │        11
                                                          1│             │              │          │     │         │
                                                           │            8│              │          │     │         │
                                                           │             │              │          │    10         │
                                                           │             │              │          │     │         │
                                                           ▼             │              │          │     │         ▼
                                                       ┌─────────────────┴─────┐       9│         ┌┴─────┴────────────────┐───────12─────────▶┌───────────────────────┐
                                                       │maybe_forward_sql_query│        └────────▶│fetch_sql_query_output │                   │   statement_to_plan   │
                                                       └───┬───────────────────┘                  └────┬──────────────────┘◀───────19─────────└───────────────────────┘
                                                           │             ▲                             │              ▲                           │               ▲
                                                           │             │                             │              │                           │               │
                                                           │             │                             │              │                           │               │
                                                           │             │                             │             35                          13              18
                                                          2│            7│                            20              │                           │               │
                                                           │             │                             │              │                           │               │
                                                           │             │                             │              │                           │               │
                                                           │             │                             │              │                           ▼               │
                                                           ▼             │                             ▼              │                       ┌───────────────────────┐
          ┌───────────────────────┐───────────6───────▶┌─────────────────┴─────┐                    ┌─────────────────┴─────┐                 │Planner::statement_to_p│
          │ forward_with_endpoint │                    │        forward        │                    │execute_plan_involving_│                 │          lan          │
          └───────────────────────┘◀────────5──────────└───┬───────────────────┘                 ┌──│    partition_table    │◀────────┐       └───┬───────────────────┘
                                                           │             ▲                       │  └───────────────────────┘         │           │              ▲
                                                           │             │                       │     │              ▲               │           │              │
                                                           │             │                       │     │              │               │          14             17
           ┌───────────────────────┐                       │            4│                       │     │              │               │           │              │
     ┌─────│ PhysicalPlan::execute │                      3│             │                       │    21              │               │           │              │
     │     └───────────────────────┘◀──┐                   │             │                       │     │             22               │           │              │
     │                                 │                   │             │                       │     │              │               │           ▼              │
     │                                 │                   │             │                       │     │              │               │       ┌────────────────────────┐
     │                                 │                   ▼             │                       │     ▼              │              34       │sql_statement_to_datafus│
     │     ┌───────────────────────┐  30               ┌─────────────────┴─────┐                 │  ┌─────────────────┴─────┐         │       │        ion_plan        │
    31     │ build_df_session_ctx  │   │               │         route         │                 │  │   build_interpreter   │         │       └────────────────────────┘
     │     └────┬──────────────────┘   │               └───────────────────────┘                 │  └───────────────────────┘         │           │              ▲
     │          │           ▲          │                                                         │                                    │           │              │
     │         27          26          │                                                        23                                    │          15             16
     │          ▼           │          │                                                         │                                    │           │              │
     └────▶┌────────────────┴──────┐   │               ┌───────────────────────┐                 │                                    │           │              │
           │ execute_logical_plan  ├───┴────32────────▶│       execute         │──────────┐      │   ┌───────────────────────┐        │           ▼              │
           └────┬──────────────────┘◀────────────25────┴───────────────────────┘         33      │   │interpreter_execute_pla│        │       ┌────────────────────────┐
                │           ▲                                           ▲                 └──────┴──▶│           n           │────────┘       │SqlToRel::sql_statement_│
               28           │                                           └──────────24────────────────┴───────────────────────┘                │   to_datafusion_plan   │
                │          29                                                                                                                 └────────────────────────┘
                ▼           │
           ┌────────────────┴──────┐
           │     optimize_plan     │
           └───────────────────────┘

</code></pre>
<ol>
<li>收到请求经过各种协议转换会转到<code>handle_sql</code>中执行,由于该请求可能是非本节点处理的，可能需要转发，进入<code>maybe_forward_sql_query</code>处理转发逻辑。</li>
<li>在<code>maybe_forward_sql_query</code>中构造好<code>ForwardRequest</code>后，调用<code>forward</code></li>
<li>在<code>forward</code>中构造好<code>RouteRequest</code>,后调用<code>route</code></li>
<li>使用<code>route</code>获取目的节点<code>endpoint</code>后回到<code>forward</code></li>
<li>调用<code>forward_with_endpoint</code>将请求进行转发</li>
<li>回到<code>forward</code></li>
<li>回到<code>maybe_forward_sql_query</code></li>
<li>回到<code>handle_sql</code></li>
<li>此时若是<code>Local</code>请求，调用<code>fetch_sql_query_output</code>进行处理</li>
<li>调用<code>parse_sql</code>将<code>sql</code>解析成<code>Statment</code></li>
<li>回到<code>fetch_sql_query_output</code></li>
<li>使用<code>Statment</code>调用<code>statement_to_plan</code></li>
<li>在其中使用<code>ctx</code>和<code>Statment</code>构造<code>Planner</code>,调用<code>Planner</code>的<code>statement_to_plan</code>方法</li>
<li><code>planner</code>中会对于请求的类别调用对应的<code>planner</code>方法，此时我们的<code>sql</code>是查询，会调用<code>sql_statement_to_plan</code></li>
<li>调用<code>sql_statement_to_datafusion_plan</code>,其中会生成<code>datafusion</code>的对象，然后调用<code>SqlToRel::sql_statement_to_plan</code></li>
<li><code>SqlToRel::sql_statement_to_plan</code>中会返回生成的逻辑计划</li>
<li>返回</li>
<li>返回</li>
<li>返回</li>
<li>调用<code>execute_plan_involving_partition_table</code>（使用默认配置情况下）进行该逻辑计划的后续优化和执行</li>
<li>调用<code>build_interpreter</code>生成<code>Interpreter</code></li>
<li>返回</li>
<li>调用<code>Interpreter</code>的<code>interpreter_execute_plan</code>方法进行逻辑计划的执行。</li>
<li>调用对应执行函数，此时<code>sql</code>是查询，所以会调用<code>SelectInterpreter</code>的<code>execute</code></li>
<li>调用<code>execute_logical_plan</code>，其中会调用<code>build_df_session_ctx</code>生成优化器</li>
<li><code>build_df_session_ctx</code>中会使用<code>config</code>信息生成对应上下文,首先使用<code>datafusion</code>和自定义的一些优化规则(在<code>logical_optimize_rules()</code>中)生成逻辑计划优化器, 使用 <code>apply_adapters_for_physical_optimize_rules</code>生成物理计划优化器</li>
<li>将优化器返回</li>
<li>调用<code>optimize_plan</code>，使用刚刚生成的优化器首先进行逻辑计划的优化随后进行物理计划的优化</li>
<li>返回优化后的物理计划</li>
<li>执行物理计划</li>
<li>执行后返回</li>
<li>收集所有分片的结果后，返回</li>
<li>返回</li>
<li>返回</li>
<li>返回</li>
<li>返回给上层进行网络协议转化，最后返回给请求发送方</li>
</ol>
<h3 id="write"><a class="header" href="#write">Write</a></h3>
<pre><code class="language-plaintext">┌───────┐      ┌───────┐      ┌───────┐
│       │──1──▶│       │──2──▶│       │
│Server │      │  SQL  │      │Catalog│
│       │◀─8───│       │◀─3───│       │
└───────┘      └───────┘      └───────┘
                │    ▲
               4│   7│
                │    │
                ▼    │
┌─────────────────────────────────────┐
│                                     │
│             Interpreter             │
│                                     │
└─────────────────────────────────────┘
      │    ▲
      │    │
      │    │
      │    │
      │    │       ┌──────────────────┐
      │    │       │                  │
     5│   6│       │   Query Engine   │
      │    │       │                  │
      │    │       └──────────────────┘
      │    │
      │    │
      │    │
      ▼    │
 ┌─────────────────────────────────────┐
 │                                     │
 │            Table Engine             │
 │                                     │
 └─────────────────────────────────────┘
</code></pre>
<p>以 <code>INSERT</code> SQL 为例，上图展示了查询过程，其中的数字表示模块之间调用的顺序。</p>
<p>以下是详细流程：</p>
<ul>
<li>Server 模块根据请求使用的协议选择合适的 rpc 模块（可能是 HTTP、gRPC 或 mysql）来处理请求；</li>
<li>使用 parser 解析请求中的 sql；</li>
<li>根据解析好的 sql 以及 catalog/schema 提供的元信息，通过 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 可以生成逻辑计划；</li>
<li>根据逻辑计划创建相应的 <code>Interpreter</code> ，并由其执行逻辑计划；</li>
<li>对于正常 <code>INSERT</code> SQL 的逻辑计划，它将通过 <code>InsertInterpreter</code> 执行；</li>
<li>在 <code>InsertInterpreter</code> 中，调用 <code>Analytic Engine</code> 提供的 <code>Table</code> 的 <code>write</code> 方法：
<ul>
<li>首先将数据写入 <code>WAL</code>；</li>
<li>然后写入 <code>MemTable</code>；</li>
</ul>
</li>
<li>在写入 <code>MemTable</code> 之前，会检查内存使用情况。如果内存使用量过高，则会触发 <code>Flush</code>：
<ul>
<li>将一些旧的 <code>MemTable</code> 持久化为 <code>SST</code>；</li>
<li>将新的 SST 信息记录到 <code>Manifest</code>；</li>
<li>记录最新 Flush 的 <code>WAL</code> 序列号；</li>
<li>删除相应的 <code>WAL</code> 日志；</li>
</ul>
</li>
<li>Server 模块将执行结果响应给客户端。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>注意：文章中提到的部分特性暂时还未实现。</p>
<h1 id="horaedb-集群"><a class="header" href="#horaedb-集群">HoraeDB 集群</a></h1>
<h2 id="整体架构"><a class="header" href="#整体架构">整体架构</a></h2>
<pre><code class="language-plaintext">┌───────────────────────────────────────────────────────────────────────┐
│                                                                       │
│                           HoraeMeta Cluster                           │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
                              ▲               ▲                 ▲
                              │               │                 │
                              │               │                 │
                              ▼               ▼                 ▼
┌───────┐Route Info ┌HoraeDB─────┬┬─┐ ┌HoraeDB─────┬┬─┐ ┌HoraeDB─────┬┬─┐
│client │◀────────▶ │  │  │TableN││ │ │  │  │TableN││ │ │  │  │TableN││ │
└───────┘Write/Query└──Shard(L)──┴┴─┘ └──Shard(F)──┴┴─┘ └──Shard(F)──┴┴─┘
                            │ │                 ▲               ▲
                              │                 │               │
                            │ Write─────────┐   ├────Sync───────┘
                                            │   │
                            │     ┌────────┬▼───┴────┬──────────────────┐
                       Upload SST │        │         │                  │
                            │     │WAL     │Region N │                  │
                                  │Service │         │                  │
                            │     └────────┴─────────┴──────────────────┘

                            ▼
┌───────────────────────────────────────────────────────────────────────┐
│                                                                       │
│                            Object Storage                             │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>上面给出来 HoraeDB 集群化方案的整体架构图，对于其中的一些名词做出解释：</p>
<ul>
<li><code>HoraeMeta Cluster</code>：集群的元数据中心，负责集群的整体调度；</li>
<li><code>Shard(L)/Shard(F)</code>: Leader Shard 和 Follower Shard，每一个 Shard 由多张 Table 组成;</li>
<li><code>HoraeDB</code>：一个 HoraeDB 实例, 包含多个 Shard；</li>
<li><code>WAL Service</code>：WAL 服务，在集群方案中，用于存储实时写入的数据；</li>
<li><code>Object Storage</code>：对象存储服务，用于存储从 memtable 生成的 SST 文件；</li>
</ul>
<p>根据架构图，读者应该对于集群化方案有一个初步的认知 —— 存储计算分离。正因如此，HoraeDB 实例本身不存储任何数据，从而使得计算存储弹性扩缩容、服务高可用和负载均衡等等有用的分布式特性比较容易实现。</p>
<h3 id="shard"><a class="header" href="#shard">Shard</a></h3>
<p>Shard 是一个重要的概念，是集群调度的基本单元，一个 Shard 包含多张表。</p>
<p>这里值得说明的是，集群调度的基本单元并非是 Table，而是采用了 Shard，主要原因在于考虑到 HoraeDB 集群如果需要支持至少百万级别的 Table 的话，而部分组件，直接处理起这个量级的 Table 可能会存在一些性能问题，例如对于 WAL 服务，如果按照 Table 去单独管理数据的话，一个重要的性能问题就在于重启后恢复新写入数据的时候，按照 Table 级别去做数据恢复的话，将会非常耗时，但按照 Shard 去管理数据的话，这个情况会改善很多，因为具体的 WAL 服务实现可以按照 Shard 这个信息，将 Table 的数据进行合理组织，从而获得比较好的数据局部性，在重启恢复的时候，就可以通过 Shard 来进行快速的数据恢复。</p>
<p>此外 Shard 具有 Leader 和 Follower 两种 Role，也就是图中的 <code>Shard(L)</code> 和 <code>Shard(F)</code>，Leader 负责读写，Follower 只有读权限，Follower 的引入其实是为了解决 HA 的问题，保证 Leader 在 crash 了之后，能快速的恢复相关表的读写服务，为了做到这一点，Follower 需要从 WAL 不停地同步最新的数据（由 Leader 写入）。</p>
<p>一个 HoraeDB 实例会拥有多个 Shard，这些 Shard 可以是 Leader 也是 Follower，以交织的方式存在:</p>
<pre><code class="language-plaintext">┌─HoraeDB Instance0──────┐     ┌─HoraeDB Instance1──────┐
│  ┌─Shard0(L)────────┐  │     │  ┌─Shard0(F)────────┐  │
│  │ ┌────┬────┬────┐ │  │     │  │ ┌────┬────┬────┐ │  │
│  │ │ T0 │ T1 │ T2 │ │  │     │  │ │ T0 │ T1 │ T2 │ │  │
│  │ └────┴────┴────┘ │  │     │  │ └────┴────┴────┘ │  │
│  └──────────────────┘  │     │  └──────────────────┘  │
│                        │     │                        │
│  ┌─Shard1(F)────────┐  │     │  ┌─Shard1(L)────────┐  │
│  │ ┌────┬────┬────┐ │  │     │  │ ┌────┬────┬────┐ │  │
│  │ │ T0 │ T1 │ T2 │ │  │     │  │ │ T0 │ T1 │ T2 │ │  │
│  │ └────┴────┴────┘ │  │     │  │ └────┴────┴────┘ │  │
│  └──────────────────┘  │     │  └──────────────────┘  │
└────────────────────────┘     └────────────────────────┘
</code></pre>
<p>上面提到集群的基本调度单元是 Shard，因此对于 Shard 存在这一些基本操作，通过这些操作可以完成一些负责的调度逻辑：</p>
<ul>
<li>向 Shard 新增/删除 Table：在建表/删表的时候使用；</li>
<li>Shard 的打开/关闭：可以用来将一个 Shard 迁移到另外一个 HoraeDB 实例上面；</li>
<li>Shard 分裂/合并：可以用来完成扩容和缩容；</li>
<li>Shard 角色切换：将一个 Shard 从 Leader 切换成 Follower，或者从 Follower 切换成 Leader；</li>
</ul>
<h3 id="horaemeta"><a class="header" href="#horaemeta">HoraeMeta</a></h3>
<p>HoraeMeta 主要负责集群的元数据管理和集群调度，其实现是通过内置一个 ETCD 来保证分布式一致性的。</p>
<p>元数据主要都是围绕 Table 来构建的，包括一些建表信息（如 Table ID），Table 所属集群（HoraeMeta 是可以支持多个 HoraeDB 集群的），Table 与 Shard 的映射关系等等。</p>
<p>HoraeMeta 的主要工作还是负责集群的调度，需要完成：</p>
<ul>
<li>接收来自 HoraeDB 实例的心跳，根据心跳来检测 HoraeDB 实例的存活状态；</li>
<li>负责 Shard 的具体分配以及调度，会将 Shard 按照一定的算法（负载均衡）分配到具体的实例上面去；</li>
<li>参与 Table 的创建，将 Table 分配到合适的 Shard（也就会分配到具体的实例）；</li>
<li>如果有新的 HoraeDB 实例加入到集群中，可以进行扩容操作；</li>
<li>如果有检测到 HoraeDB 实例的下线状况，可以完成自动的故障恢复；</li>
</ul>
<h3 id="路由"><a class="header" href="#路由">路由</a></h3>
<p>为了避免转发请求的开销，客户端与 HoraeDB 实例之间的通信是点对点的，也就是说，客户端在发送任何特定的写入/查询请求之前，应该从服务器获取路由信息。</p>
<p>实际上，路由信息是由 HoraeMeta 决定的，但是客户端只允许通过 HoraeDB 实例而不是 HoraeMeta 来访问它，以避免由 HoraeMeta 引起的潜在性能瓶颈。</p>
<h3 id="wal-service--object-storage"><a class="header" href="#wal-service--object-storage">WAL Service &amp; Object Storage</a></h3>
<p>在集群方案中，<code>WAL Service</code> 和 <code>Object Storage</code> 都是作为独立的服务而存在的，并且是具备容灾能力的分布式系统。目前 <code>WAL Service</code> 的实现，在集群化方案中主要包括两种实现：<code>Kafka</code> 和 <code>OBKV</code>（通过其提供的 Table API 访问 <code>OceanBase</code>）；而 <code>Object Storage</code> 的实现比较多，基本覆盖了主流的对象存储服务。</p>
<p>这两个系统的相似之处在于，它们是作为计算存储分离架构中的的存储层；而它们的区别也很明显，<code>WAL Service</code> 具备较高的实时写入性能（高吞吐、低延时），负责实时的新增数据写入，而 <code>Object Storage</code> 具备低成本的存储代价和较为高效的查询吞吐，负责后台整理好的、长期存储的数据读写。</p>
<p>这两个服务组件的引入，使得 HoraeDB 集群的水平扩容、服务高可用、负载均衡提供了实现基础。</p>
<h2 id="水平扩容"><a class="header" href="#水平扩容">水平扩容</a></h2>
<p>集群的扩展能力是评价一个集群方案的重要指标，下面从存储和计算两方面来介绍一下 HoraeDB 集群的水平扩容能力是如何实现的。</p>
<h3 id="存储"><a class="header" href="#存储">存储</a></h3>
<p>很明显，在选择 WAL Service 和 Object Storage 两个底层服务实现的时候，水平扩容能力是必须的，存储容量出现问题的时候，可以单独地进行存储服务的扩容。</p>
<h3 id="计算"><a class="header" href="#计算">计算</a></h3>
<p>计算能力的水平扩容可能会复杂一下，考虑如下几个容量问题：</p>
<ul>
<li>大量查询大量的表；</li>
<li>大量查询同一张数据量大的表；</li>
<li>大量查询同一张正常的表；</li>
</ul>
<p>对于第一种情况，通过 Shard 分裂，将分裂出来的新 Shard 迁移到新扩容的 HoraeDB 实例，这样表就会分散到新的实例上。</p>
<p>对于第二种情况，可以通过表分区的功能，将该表分成多个子表，从而达到水平扩容的效果；</p>
<p>第三种情况是最重要也是最难处理的。事实上，Follower Shard 可以为 Leader Shard 分担部分查询请求，但是由于 Follower Shard 需要同步数据，它的数量是受到 WAL 同步能力的限制的。实际上，从下图可以看到，对于这样的场景（当 Follower Shard 不足以承担住访问量的时候），可以考虑在集群中添加一种纯计算节点，其中的 Shard 不参与实时的数据同步，当这个实例被访问的时候，新写入的实时数据可以从 Leader Shard 或者 Follower Shard 恢复出来，历史的数据可以直接从 <code>Object Storage</code> 获取并缓存，这样的话，就可以在一定程度上（实际上还是存在单表的实时数据拉取的瓶颈，但是考虑到这部分数据并非特别多，理论上这个瓶颈应该比较难以达到），达到水平扩容的效果。</p>
<pre><code class="language-plaintext">                                             ┌HoraeDB─────┬┬─┐
                            ┌──newly written─│  │  │TableN││ │
                            ▼                └──Shard(L/F)┴┴─┘
┌───────┐  Query  ┌HoraeDB─────┬┬─┐
│client │────────▶│  │  │TableN││ │
└───────┘         └──Shard─────┴┴─┘          ┌───────────────┐
                            ▲                │    Object     │
                            └───old SST──────│    Storage    │
                                             └───────────────┘
</code></pre>
<h2 id="high-availability"><a class="header" href="#high-availability">High Availability</a></h2>
<p>通过上面的介绍，HoraeDB 的高可用方案，其实比较自然了。考虑某台 HoraeDB 实例 Crash 了，后续的服务恢复步骤整体如下：</p>
<ul>
<li>HoraeMeta 通过发现心跳断了，判断该 HoraeDB 实例下线；</li>
<li>HoraeMeta 选择将该实例上的所有 Leader Shard 所对应的 Follower Shard，切换成 Leader Shard，从而完成快速恢复；</li>
<li>如果没有对应的 Follower Shard 存在，那么需要执行 Open Shard 操作，不过这样的恢复是较慢的；</li>
</ul>
<pre><code class="language-plaintext">┌─────────────────────────────────────────────────────────┐
│                                                         │
│                    HoraeMeta Cluster                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
                             ▲
             ┌ ─ ─Broken ─ ─ ┤
                             │
             │               │
┌ HoraeDB Instance0 ─ ─ ─    │   ┌─HoraeDB Instance1──────┐                   ┌─HoraeDB Instance1──────┐
   ┌─Shard0(L)────────┐  │   │   │  ┌─Shard0(F)────────┐  │                   │  ┌─Shard0(L)────────┐  │
│  │ ┌────┬────┬────┐ │      │   │  │ ┌────┬────┬────┐ │  │                   │  │ ┌────┬────┬────┐ │  │
   │ │ T0 │ T1 │ T2 │ │  │   ├───│  │ │ T0 │ T1 │ T2 │ │  │                   │  │ │ T0 │ T1 │ T2 │ │  │
│  │ └────┴────┴────┘ │      │   │  │ └────┴────┴────┘ │  │                   │  │ └────┴────┴────┘ │  │
   └──────────────────┘  │   │   │  └──────────────────┘  │     Failover      │  └──────────────────┘  │
│                            │   ├─HoraeDB Instance2──────┤   ───────────▶    ├─HoraeDB Instance2──────┤
   ┌─Shard1(L)────────┐  │   │   │  ┌─Shard1(F)────────┐  │                   │  ┌─Shard1(L)────────┐  │
│  │ ┌────┬────┬────┐ │      │   │  │ ┌────┬────┬────┐ │  │                   │  │ ┌────┬────┬────┐ │  │
   │ │ T0 │ T1 │ T2 │ │  │   └───│  │ │ T0 │ T1 │ T2 │ │  │                   │  │ │ T0 │ T1 │ T2 │ │  │
│  │ └────┴────┴────┘ │          │  │ └────┴────┴────┘ │  │                   │  │ └────┴────┴────┘ │  │
   └──────────────────┘  │       │  └──────────────────┘  │                   │  └──────────────────┘  │
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─        └────────────────────────┘                   └────────────────────────┘
</code></pre>
<h2 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h2>
<p>HoraeDB 上传的心跳信息会带上机器的负载信息，HoraeMeta 会根据这些信息，完成自动的负载均衡的调度工作，主要包括：</p>
<ul>
<li>新建表的时候，为该表挑选一个负载低的实例上面的 Shard；</li>
<li>将负载高的实例上的 Shard 迁移到负载低的实例；</li>
<li>更好地，可以根据 Shard 的负载，通过 Shard 的分裂和合并，来完成更细粒度的负载均衡；</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-nothing-架构"><a class="header" href="#shared-nothing-架构">Shared Nothing 架构</a></h1>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p>在 <a href="design/./clustering.html">集群</a> 文章中介绍了 HoraeDB 的集群方案，简单总结一下就是：</p>
<ul>
<li>计算存储分离；</li>
<li>由中心化的元数据中心，管理整个集群；</li>
</ul>
<p>然而计算存储分离的架构下，有个重要的问题在于，在集群调度的过程中，如何保证在共享的存储层中的数据不会因为不同的计算节点访问导致数据损坏，一个简单的例子就是如果同一块数据块被多个计算节点同时更新，可能就会出现数据损坏。</p>
<p>而 HoraeDB 的解决方案是通过特定的机制，在共享存储的情况下达到了类似 <a href="https://en.wikipedia.org/wiki/Shared-nothing_architecture">Shared-Nothing 架构</a> 的效果，也就是说存储层的数据经过一定规则的划分，<strong>可以保证在任何时刻最多只有一个 HoraeDB 实例可以对其进行更新</strong>，本文中，将这个特性定义成<strong>集群拓扑的正确性</strong>，如果这个正确性得到保证的话，那么数据就不会因为集群的灵活调度而受到损坏。</p>
<p>本文对于 Shared Nothing 架构的优劣不做赘述，主要分享一下，HoraeDB 集群方案是如何在计算存储分离的方案下，达到 Shared Nothing 的效果（即如何保证 <strong>集群拓扑的正确性</strong>）。</p>
<h2 id="数据划分"><a class="header" href="#数据划分">数据划分</a></h2>
<p>为了达到 Shared Nothing 的效果，首先需要将数据在共享的存储层上面进行好逻辑和物理的划分。在 <a href="design/./clustering.html#shard">此前的集群介绍文章</a> 中介绍了 Shard 的基本作用，作为集群的基本调度单元，同时也是数据分布的基本划分单元，不同的 Shard 在存储层对应的数据是隔离的：</p>
<ul>
<li>在 WAL 中，写入的 Table 数据会按照 Shard 组织起来，按照 Shard 写入到 WAL 的不同区域中，不同的 Shard 在 WAL 中的数据是隔离开的；</li>
<li>在 Object Storage 中，数据的管理是按照 Table 来划分的，而 Shard 和 Table 之间的关系是一对多的关系，也就说，任何一个 Table 只属于一个 Shard，因此在 Object Storage 中，Shard 之间的数据也是隔离的；</li>
</ul>
<h2 id="shard-lock"><a class="header" href="#shard-lock">Shard Lock</a></h2>
<p>在数据划分好之后，需要保证的就是在任何时刻，同一时刻最多只有一个 HoraeDB 实例能够更新 Shard 的数据。那么要如何保证这一点的呢？很自然地，通过锁可以达到互斥的效果，不过在分布式集群中，我们需要的是分布式锁。通过分布式锁，每一个 Shard 被分配给 HoraeDB 实例时，HoraeDB 必须先获取到相应的 Shard Lock，才能完成 Shard 的打开操作，对应地，当 Shard 关闭后，HoraeDB 实例也需要主动释放 Shard Lock。</p>
<p>HoraeDB 集群的元数据服务 HoraeMeta 是基于 ETCD 构建的，而基于 ETCD 实现分布式的 Shard Lock 是非常方便的，因此我们选择基于现有的 ETCD 实现 Shard Lock，具体逻辑如下：</p>
<ul>
<li>以 Shard ID 作为 ETCD 的 Key，获取到 Shard Lock 等价于创建出这个 Key；</li>
<li>对应的 Value，可以把 HoraeDB 的地址编码进去（用于 HoraeMeta 调度）；</li>
<li>Shard Lock 获取到了之后，HoraeDB 实例需要通过 ETCD 提供的接口对其进行续租，保证 Shard Lock 不会被释放；</li>
</ul>
<p>HoraeMeta 暴露了 ETCD 的服务提供给 HoraeDB 集群来构建 Shard Lock，下图展示了 Shard Lock 的工作流程，图中的两个 HoraeDB 实例都尝试打开 Shard 1，但是由于 Shard Lock 的存在，最终只有一个 HoraeDB 实例可以完成 Shard 1 的打开：</p>
<pre><code>             ┌────────────────────┐
             │                    │
             │                    │
             ├───────┐            │
   ┌─────┬──▶│ ETCD  │            │
   │     │   └───────┴────HoraeMeta
   │     │       ▲
   │     │       └──────┬─────┐
   │     │          Rejected  │
   │     │              │     │
┌─────┬─────┐        ┌─────┬─────┐
│Shard│Shard│        │Shard│Shard│
│  0  │  1  │        │  1  │  2  │
├─────┴─────┤        ├─────┴─────┤
└─────HoraeDB        └─────HoraeDB
</code></pre>
<h2 id="其他方案"><a class="header" href="#其他方案">其他方案</a></h2>
<p>Shard Lock 的方案本质上是 HoraeDB 通过 ETCD 来保证在集群中<strong>对于任何一个 Shard 在任何时刻最多只有一个 HoraeDB 实例可以对其进行更新操作</strong>，也就是保证了在任何时刻 <strong>集群拓扑的正确性</strong>，需要注意，这个保证实际上成为了 HoraeDB 实例提供的能力（虽然是利用 ETCD 来实现的），而 HoraeMeta 无需保证这一点，下面的对比中，这一点是一个非常大的优势。</p>
<p>除此 Shard Lock 的方案，我们还考虑过这样的两种方案：</p>
<h3 id="horaemeta-状态同步"><a class="header" href="#horaemeta-状态同步">HoraeMeta 状态同步</a></h3>
<p>HoraeMeta 规划并存储集群的拓扑状态，保证其<strong>正确性</strong>，并将这个正确的拓扑状态同步到 HoraeDB，而 HoraeDB 本身无权决定 Shard 是否可以打开，只有在得到 HoraeMeta 的通知后，才能打开指定的 Shard。此外，HoraeDB 需要不停地向 HoraeMeta 发送心跳，一方面汇报自身的负载信息，另一方面让 HoraeMeta 知道该节点仍然在线，用以计算最新的正确的拓扑状态。</p>
<p>该方案也是 HoraeDB 一开始采用的方案，该方案的思路简洁，但是在实现过程中却是很难做好的，其难点在于，HoraeMeta 在执行调度的时候，需要基于最新的拓扑状态，决策出一个新的变更，并且应用到 HoraeDB 集群，但是这个变更到达某个具体的 HoraeDB 实例时，即将产生效果的时候，该方案无法简单地保证此刻的集群状态仍然是和做出该变更决策时基于的那个集群状态是一致的。</p>
<p>让我们用更精确的语言描述一下：</p>
<pre><code>t0: 集群状态是 S0，HoraeMeta 据此计算出变更 U；
t1: HoraeMeta 将 U 发送到某个 HoraeDB 实例，让其执行变更；
t2: 集群状态变成 S1；
t3: HoraeDB 接收到 U，准备进行变更；
</code></pre>
<p>上述的例子的问题在于，t3 时刻，HoraeDB 执行变更 U 是否正确呢？执行这个变更 U，是否会让数据遭到损坏？这个正确性，需要 HoraeMeta 完成相当复杂的逻辑来保证即使在集群状态为 S1 的情况下，执行 U 变更也不会出现问题，除此之外，状态的回滚也是一个非常麻烦的过程。</p>
<p>举一个例子，就可以发现这个方案的处理比较麻烦：</p>
<pre><code>t0: HoraeMeta 尝试在 HoraeDB0 打开 Shard0，然而 HoraeDB0 打开 Shard0 遇到一些问题，Hang 住了，HoraeMeta 只能在超时之后，认为打开失败；
t1: HoraeMeta 计算出新的拓扑结构，尝试在 HoraeDB1 继续打开 Shard0；
t2: HoraeDB0 和 HoraeDB1 可能会同时打开 Shard0；
</code></pre>
<p>自然是有一些办法来避免掉 t2 时刻的事情，比如在 t0 时刻失败了之后，需要等待一个心跳周期，来获知 HoraeDB0 是否仍然在尝试打开 Shard0，来避免 t1 时刻发出的命令，但是这样的逻辑比较繁琐，难以维护。</p>
<p>对比 Shard Lock 的方案，可以发现，该方案尝试获得更强的一致性，即尝试保证集群的拓扑状态在任何时刻都需要和 HoraeMeta 中的集群状态保持一致，显然，这样的一致性肯定是能够保证<strong>集群拓扑的正确性</strong>的，但也正因为如此实现起来才会更加复杂，而基于 Shard Lock 的方案放弃了这样一个<strong>已知</strong>的、正确的集群拓扑状态，转而只需要保证集群状态是正确的即可，而不需要知道这个状态究竟是什么。更重要的是，从另外一个角度来看，保证<strong>集群拓扑的正确性</strong>这部分逻辑和集群的调度完成了解耦，因此 HoraeMeta 的逻辑大大简化，只需要专注于完成负载均衡的集群调度工作即可，而集群拓扑的正确性由 HoraeDB 本身来保证。</p>
<h2 id="horaedb-提供一致性协议"><a class="header" href="#horaedb-提供一致性协议">HoraeDB 提供一致性协议</a></h2>
<p>该方案是参考 TiDB 的元数据服务 <a href="https://github.com/tikv/pd">PD</a> 的，PD 管理着所有的 TiKV 数据节点，但是 PD 不需要维护一致性的集群状态，并且应用到 TiKV 节点上面去，因为 TiKV 集群中，每一个 Raft Group，都能够达到一致性，也就是说 TiKV 无需借助 PD，本身就具备了让整个集群拓扑正确的能力（一个 Raft Group 不会出现两个 Leader）。</p>
<p>参考该方案，实际上我们也可以在 HoraeDB 实例之间实现一致性协议，让其本身也具备这样的能力，不过在 HoraeDB 之间引入一致性协议，似乎把事情变得更加复杂了，而且目前也没有更多的数据需要同步，通过外部的服务（ETCD）依然可以同样的效果，从 HoraeMeta 看，就等价于 HoraeDB 本身获得了让集群一致的能力。</p>
<p>因此 Shard Lock 的方案，可以看作是该方案的一个变种，是一种取巧但是很实用的实现。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>HoraeDB 分布式方案的最终目标自然不是保证集群拓扑正确就够了，但是保持正确性是后续特性的重要基石，一旦这部分的逻辑简洁明了，有充分的理论保证，就可以让后续的特性实现也同样的优雅、简洁。例如，为了使得 HoraeDB 集群中的各个节点达到负载均衡的效果，HoraeMeta 就必须根据 HoraeDB 实例上报的消息，对集群中的节点进行调度，而调度的单位必然是 Shard，然而任何一次 Shard 的变动都可能造成数据的损坏（一个 Shard 被两个实例同时打开），在有了 Shard Lock 的保证后，HoraeMeta 就可以放心地生成调度计划，根据上报的负载信息，计算出当前状态的最佳调度结果，然后发送到涉及的 HoraeDB 实例让其执行，即使计算的前提可能是错误的（即集群状态已经和计算出调度结果时的状态不一样了），也不用担心集群拓扑的正确性遭到破坏，因而 HoraeMeta 的调度逻辑，变得简洁而优雅（只需要生成、执行，不需要考虑失败处理）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储引擎"><a class="header" href="#存储引擎">存储引擎</a></h1>
<p>存储引擎主要提供以下两个功能：</p>
<ol>
<li>数据的持久化</li>
<li>在保证数据正确性的前提下，用最合理的方式来组织数据，来满足不同场景的查询需求</li>
</ol>
<p>本篇文档就来介绍 HoraeDB 中存储引擎的内部实现，读者可以参考这里面的内容，来探索如何高效使用 HoraeDB。</p>
<h1 id="整体架构-1"><a class="header" href="#整体架构-1">整体架构</a></h1>
<p>HoraeDB 是一种基于 share-nothing 架构的分布式存储系统，不同服务器之间的数据相互隔离，互不影响。每一个单机中的存储引擎是 LSM（Log-structured merge-tree）的一个变种，针对时序场景做了优化，下图展示了其主要组件的运作方式：</p>
<p><img src="design/../../resources/images/storage-overview.svg" alt="" /></p>
<h2 id="write-ahead-log-wal"><a class="header" href="#write-ahead-log-wal">Write Ahead Log (WAL)</a></h2>
<p>一次写入请求的数据会写到两个部分：</p>
<ol>
<li>内存中的 memtable</li>
<li>可持久化的 WAL</li>
</ol>
<p>由于 memtable 不是实时持久化到底层存储系统，因此需要用 WAL 来保证 memtable 中数据的可靠性。</p>
<p>另一方面，由于<a href="design/cluster.html">分布式架构</a>的设计，要求 WAL 本身是高可用的，现在 HoraeDB 中，主要有以下几种实现：</p>
<ul>
<li><a href="design/wal_on_rocksdb.html">本地磁盘</a>（基于 <a href="http://rocksdb.org/">RocksDB</a>，无分布式高可用）</li>
<li><a href="https://www.oceanbase.com">Oceanbase</a></li>
<li><a href="design/wal_on_kafka.html">Kafka</a></li>
</ul>
<h2 id="memtable-1"><a class="header" href="#memtable-1">Memtable</a></h2>
<p>Memtable 是一个内存的数据结构，用来保存最近写入的数据。一个表对应一个 memtable。</p>
<p>Memtable 默认是可读写的（称为 active），当写入达到一起阈值时，会变成只读的并且被一个新的 memtable 替换掉。只读的 memtable 会被后台线程以 SST 的形式写入到底层存储系统中，写入完成后，只读的 memtable 就可以被销毁，同时 WAL 中也可以删除对应部分的数据。</p>
<h2 id="sorted-string-tablesst"><a class="header" href="#sorted-string-tablesst">Sorted String Table（SST）</a></h2>
<p>SST 是数据的持久化格式，按照表主键的顺序存放，目前 HoraeDB 采用 parquet 格式来存储。</p>
<p>对于 HoraeDB 来说，SST 有一个重要特性： <code>segment_duration</code>，只有同一个 segment 内的 SST 才有可能进行合并操作。而且有了 segment，也方便淘汰过期的数据。</p>
<p>除了存放原始数据外，SST 内也会存储数据的统计信息来加速查询，比如：最大值、最小值等。</p>
<h2 id="compactor"><a class="header" href="#compactor">Compactor</a></h2>
<p>Compactor 可以把多个小 SST 文件合并成一个，用于解决小文件数过多的问题。此外，Compactor 也会在合并时进行过期数据的删除，重复数据的去重。目前 HoraeDB 中的合并策略参考自 Cassandra，主要有两个：</p>
<ul>
<li><a href="https://cassandra.apache.org/doc/latest/cassandra/operating/compaction/stcs.html">SizeTieredCompactionStrategy</a></li>
<li><a href="https://cassandra.apache.org/doc/latest/cassandra/operating/compaction/twcs.html">TimeWindowCompactionStrategy</a></li>
</ul>
<h2 id="manifest-1"><a class="header" href="#manifest-1">Manifest</a></h2>
<p>Manifest 记录表、SST 文件元信息，比如：一个 SST 内数据的最小、最大时间戳。</p>
<p>由于分布式架构的设计，要求 Manifest 本身是高可用的，现在 HoraeDB 中，主要有以下几种实现：</p>
<ul>
<li>WAL</li>
<li>ObjectStore</li>
</ul>
<h2 id="objectstore"><a class="header" href="#objectstore">ObjectStore</a></h2>
<p>ObjectStore 是数据（即 SST）持久化的地方，一般来说各大云厂商均有对应服务，像阿里云的 OSS，AWS 的 S3。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wal-1"><a class="header" href="#wal-1">Wal</a></h1>
<ul>
<li><a href="design/wal_on_rocksdb.html">WAL on RocksDB</a></li>
<li><a href="design/wal_on_kafka.html">WAL on Kafka</a></li>
<li>基于 OceanBase 的 WAL 未来再做介绍</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于-rocksdb-的-wal"><a class="header" href="#基于-rocksdb-的-wal">基于 RocksDB 的 WAL</a></h1>
<h2 id="架构-1"><a class="header" href="#架构-1">架构</a></h2>
<p>在本节中，我们将介绍单机版 WAL 的实现（基于 RocksDB）。预写日志（write-ahead logs，以下简称日志）在本实现中是按表级别进行管理的，对应的数据结构为 <code>TableUnit</code>。为简单起见，所有相关数据（日志或元数据）都存储在单个 column family（RocksDB 中的概念，可以类比关系型数据库的表） 中。</p>
<pre><code class="language-text">            ┌─────────────────────────┐
            │         HoraeDB         │
            │                         │
            │ ┌─────────────────────┐ │
            │ │         WAL         │ │
            │ │                     │ │
            │ │        ......       │ │
            │ │                     │ │
            │ │  ┌────────────────┐ │ │
 Write ─────┼─┼──►   TableUnit    │ │ │
            │ │  │                │ │ │
 Read  ─────┼─┼──► ┌────────────┐ │ │ │
            │ │  │ │ RocksDBRef │ │ │ │
            │ │  │ └────────────┘ │ │ │
Delete ─────┼─┼──►                │ │ │
            │ │  └────────────────┘ │ │
            │ │        ......       │ │
            │ └─────────────────────┘ │
            │                         │
            └─────────────────────────┘
</code></pre>
<h2 id="数据模型-1"><a class="header" href="#数据模型-1">数据模型</a></h2>
<h3 id="通用日志格式"><a class="header" href="#通用日志格式">通用日志格式</a></h3>
<p>通用日志格式分为 key 格式和 value 格式，下面是对 key 格式各个字段的介绍:</p>
<ul>
<li><code>namespace</code>: 出于不同的目的，可能会存在多个 WAL 实例（例如，manifest 也依赖于 wal）, <code>namespace</code> 用于区分它们。</li>
<li><code>region_id</code>: 在一些 WAL 实现中我们可能需要在共享日志文件中，管理来自多个表的日志，<code>region</code> 就是描述这样一组表的概念， 而 <code>region id</code> 就是其标识。</li>
<li><code>table_id</code>: 表的标识。</li>
<li><code>sequence_num</code>: 特定表中单条日志的标识。</li>
<li><code>version</code>: 用于兼容新旧格式。</li>
</ul>
<pre><code class="language-text">+---------------+----------------+-------------------+--------------------+-------------+
| namespace(u8) | region_id(u64) |   table_id(u64)   |  sequence_num(u64) | version(u8) |
+---------------+----------------+-------------------+--------------------+-------------+
</code></pre>
<p>下面是对 value 格式各个字段的介绍(<code>payload</code> 可以理解为编码后的具体日志内容):</p>
<pre><code class="language-text">+--------------------+----------+
| version header(u8) | payload  |
+--------------------+----------+
</code></pre>
<h3 id="元数据"><a class="header" href="#元数据">元数据</a></h3>
<p>与日志格式相同，元数据以 key-value 格式存储, 本实现的元数据实际只是存储了每张表最近一次 flush 对应的 <code>sequence_num</code>。下面是定义的元数据 key 格式和其中字段的介绍：</p>
<ul>
<li><code>namespace</code>, <code>table_id</code>, <code>version</code> 和日志格式中相同。</li>
<li><code>key_type</code>, 用于定义元数据的类型，现在只定义了 MaxSeq 类型的元数据，在。
因为在 RocksDB 版本的 WAL 实现中，日志是按表级别进行管理，所以这个 key 格式里面没有 <code>region_id</code> 字段。</li>
</ul>
<pre><code class="language-text">+---------------+--------------+----------------+-------------+
| namespace(u8) | key_type(u8) | table_id(u64)  | version(u8) |
+---------------+--------------+----------------+-------------+
</code></pre>
<p>这是定义的元数据值格式，如下所示，其中只有 <code>version</code> 和 <code>max_seq</code>(flushed sequence):</p>
<pre><code class="language-text">+-------------+--------------+
| version(u8) | max_seq(u64) |
+-------------+--------------+
</code></pre>
<h2 id="主要流程"><a class="header" href="#主要流程">主要流程</a></h2>
<ul>
<li>打开 <code>TableUnit</code>:
<ul>
<li>读取所有表的最新日志条目，目的是恢复表的 next sequence num(将会分配给下一条写入的日志)。</li>
<li>扫描 metadata 恢复上一步遗漏的表的 next sequence num（因为可能有表刚刚触发了 fl​​ush，并且之后没有新的写入日志，所以当前不存在日志数据）。</li>
</ul>
</li>
<li>读写日志。从 RocksDB 读取或者写入相关日志数据。</li>
<li>删除日志。为简单起见，在本实现中只是同步地删除相应的日志数据。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于-kafka-的-wal"><a class="header" href="#基于-kafka-的-wal">基于 Kafka 的 WAL</a></h1>
<h2 id="架构-2"><a class="header" href="#架构-2">架构</a></h2>
<p>在本节中，将会介绍一种分布式 WAL 实现（基于 Kafka）。表的预写日志（write-ahead logs，以下简称日志）在本实现中是按 region 级别管理的，region 可以简单理解为多个表的共享日志文件。</p>
<p>如下图所示，在本实现中将 region 映射到 Kafka 中的 topic（只有一个 partition）。 通常一个 region 需要两个 topic ，一个用于存储日志，另一个用于存储元数据。</p>
<pre><code class="language-text">                                                 ┌──────────────────────────┐
                                                 │         Kafka            │
                                                 │                          │
                                                 │         ......           │
                                                 │                          │
                                                 │ ┌─────────────────────┐  │
                                                 │ │      Meta Topic     │  │
                                                 │ │                     │  │
                                         Delete  │ │ ┌─────────────────┐ │  │
               ┌──────────────────────┐  ┌───────┼─┼─►    Partition    │ │  │
               │       HoraeDB        │  │       │ │ │                 │ │  │
               │                      │  │       │ │ └─────────────────┘ │  │
               │ ┌──────────────────┐ │  │       │ │                     │  │
               │ │       WAL        │ │  │       │ └─────────────────────┘  │
               │ │      ......      │ │  │       │                          │
               │ │ ┌──────────────┐ │ │  │       │ ┌──────────────────────┐ │
               │ │ │    Region    │ │ │  │       │ │     Data Topic       │ │
               │ │ │              ├─┼─┼──┘       │ │                      │ │
               | | | ┌──────────┐ │ │ │          │ │ ┌──────────────────┐ │ │
               │ │ │ │ Metadata │ │ │ │          │ │ │    Partition     │ │ │
               │ │ │ └──────────┘ │ │ │    Write │ │ │                  │ │ │
Write ─────────┼─┼─►              ├─┼─┼───┐      │ │ │ ┌──┬──┬──┬──┬──┐ │ │ │
               │ │ │ ┌──────────┐ │ │ │   └──────┼─┼─┼─►  │  │  │  │  ├─┼─┼─┼────┐
               │ │ │ │  Client  │ │ │ │          │ │ │ └──┴──┴──┴──┴──┘ │ │ │    │
Read ◄─────────┼─┼─┤ └──────────┘ │ │ │          │ │ │                  │ │ │    │
               │ │ │              │ │ │          │ │ └──────────────────┘ │ │    │
               │ │ └──▲───────────┘ │ │          │ │                      │ │    │
               │ │    │ ......      │ │          │ └──────────────────────┘ │    │
               │ └────┼─────────────┘ │          │         ......           │    │
               │      │               │          └──────────────────────────┘    │
               └──────┼───────────────┘                                          │
                      │                                                          │
                      │                                                          │
                      │                        Read                              │
                      └──────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="数据模型-2"><a class="header" href="#数据模型-2">数据模型</a></h2>
<h3 id="日志格式"><a class="header" href="#日志格式">日志格式</a></h3>
<p>日志格式采用了在 <a href="design/wal_on_rocksdb.html">基于 RocksDB 的 WAL</a> 中定义的通用格式。</p>
<h3 id="元数据-1"><a class="header" href="#元数据-1">元数据</a></h3>
<p>每个 region 都将在内存和 Kafka 中维护其元数据，我们在这里称之为 <code>RegionMeta</code>。它可以被认为是一张映射表，以表 ID 作为键，以 <code>TableMeta</code> 作为值。我们简要介绍一下 <code>TableMeta</code> 中的变量：</p>
<ul>
<li><code>next_seq_num</code>，为下一条写入日志分配的 sequence number。</li>
<li><code>latest_marked_deleted</code>，表最后一次触发 flush 时对应的 sequence number, 所以对应 sequence number 小于该值的日志都将被标记为可以删除。</li>
<li><code>current_high_watermark</code>， 该表最近一次日志写入后，Kafka 对应 topic 的高水位。</li>
<li><code>seq_offset_mapping</code>，sequence number 和 Kafka 对应 topic offset 的映射，每次 flush 后，会将 <code>latest_marked_deleted</code> 前的条目进行清理。</li>
</ul>
<pre><code>┌─────────────────────────────────────────┐
│              RegionMeta                 │
│                                         │
│ Map&lt;TableId, TableMeta&gt; table_metas     │
└─────────────────┬───────────────────────┘
                  │
                  │
                  │
                  └─────┐
                        │
                        │
 ┌──────────────────────┴──────────────────────────────┐
 │                       TableMeta                     │
 │                                                     │
 │ SequenceNumber next_seq_num                         │
 │                                                     │
 │ SequenceNumber latest_mark_deleted                  │
 │                                                     │
 │ KafkaOffset high_watermark                          │
 │                                                     │
 │ Map&lt;SequenceNumber, KafkaOffset&gt; seq_offset_mapping │
 └─────────────────────────────────────────────────────┘
</code></pre>
<h2 id="主要流程-1"><a class="header" href="#主要流程-1">主要流程</a></h2>
<p>我们主要关于对于单个 region 的主要操作，会介绍以下操作的主要流程：</p>
<ul>
<li>打开或创建 region。</li>
<li>读写日志。</li>
<li>删除日志。</li>
</ul>
<h3 id="打开或创建-region"><a class="header" href="#打开或创建-region">打开或创建 region</a></h3>
<h4 id="步骤"><a class="header" href="#步骤">步骤</a></h4>
<ul>
<li>在打开的 namespace 中搜索 region。</li>
<li>如果 region 存在，最重要的事是去恢复其元数据，恢复过程将在之后介绍。</li>
<li>如果 region 不存在并且需要自动创建，则需要在 Kafka 上创建对应的 topic。</li>
<li>在 cache 中插入相应 region 并将其返回。</li>
</ul>
<h4 id="恢复"><a class="header" href="#恢复">恢复</a></h4>
<p>上面提到，<code>RegionMeta</code> 实际就是以表 ID 为键，以 <code>TableMeta</code> 为值的映射表。因此，我们在本节中只关注特定 <code>TableMeta</code> 的恢复即可，将在每步的介绍中加入例子以作更好的说明。</p>
<ul>
<li>从快照中恢复。我们会在某些场景下为 <code>RegionMeta</code>制作快照（例如当标记日志为可删除时，真正清理日志时），并且将其写到 meta topic 中，快照实际上就是在某个时间点的 <code>RegionMeta</code>。当恢复 region 时，我们可以使用快照来避免扫描 data topic 的全部数据。下面为上述过程对应的例子，我们从在 Kafka 高水位为 64 的时间点时制作的快照中恢复 <code>RegionMeta</code>：</li>
</ul>
<pre><code class="language-text">high watermark in snapshot: 64

 ┌──────────────────────────────┐
 │         RegionMeta           │
 │                              │
 │          ......              │
 │ ┌──────────────────────────┐ │
 │ │       TableMeta          │ │
 │ │                          │ │
 │ │ next_seq_num: 5          │ │
 │ │                          │ │
 │ │ latest_mark_deleted: 2   │ │
 │ │                          │ │
 │ │ high_watermark: 32       │ │
 │ │                          │ │
 │ │ seq_offset_mapping:      │ │
 │ │                          │ │
 │ │ (2, 16) (3, 16) (4, 31)  │ │
 │ └──────────────────────────┘ │
 │          ......              │
 └──────────────────────────────┘
</code></pre>
<ul>
<li>从日志数据中恢复。 当从快照中恢复的过程完成后，我们以快照被制作时 data topic 中的高水位为起点，扫描其中的日志数据进行后续恢复，明显这能够避免扫描 data topic 中的全部数据。以下为上述过程的例子：</li>
</ul>
<pre><code class="language-text">┌────────────────────────────────────┐
│                                    │
│    high_watermark in snapshot: 64  │
│                                    │
│  ┌──────────────────────────────┐  │
│  │         RegionMeta           │  │
│  │                              │  │
│  │          ......              │  │
│  │ ┌──────────────────────────┐ │  │
│  │ │       TableMeta          │ │  │
│  │ │                          │ │  │
│  │ │ next_seq_num: 5          │ │  │                  ┌────────────────────────────────┐
│  │ │                          │ │  │                  │          RegionMeta            │
│  │ │ latest_mark_deleted: 2   │ │  │                  │                                │
│  │ │                          │ │  │                  │            ......              │
│  │ │ high_watermark: 32       │ │  │                  │ ┌────────────────────────────┐ │
│  │ │                          │ │  │                  │ │         TableMeta          │ │
│  │ │ seq_offset_mapping:      │ │  │                  │ │                            │ │
│  │ │                          │ │  │                  │ │ next_seq_num: 8            │ │
│  │ │ (2, 16) (3, 16) (4, 31)  │ │  │                  │ │                            │ │
│  │ └──────────────────────────┘ │  │                  │ │ latest_mark_deleted: 2     │ │
│  │          ......              │  │                  │ │                            │ │
│  └──────────────────────────────┘  ├──────────────────► │ high_watermark: 32         │ │
│                                    │                  │ │                            │ │
│ ┌────────────────────────────────┐ │                  │ │ seq_offset_mapping:        │ │
│ │          Data topic            │ │                  │ │                            │ │
│ │                                │ │                  │ │ (2, 16) (3, 16) (4, 31)    │ │
│ │ ┌────────────────────────────┐ │ │                  │ │                            │ │
│ │ │        Partition           │ │ │                  │ │ (5, 72) (6, 81) (7, 90)    │ │
│ │ │                            │ │ │                  │ │                            │ │
│ │ │ ┌────┬────┬────┬────┬────┐ │ │ │                  │ └────────────────────────────┘ │
│ │ │ │ 64 │ 65 │ ...│ 99 │100 │ │ │ │                  │             ......             │
│ │ │ └────┴────┴────┴────┴────┘ │ │ │                  └────────────────────────────────┘
│ │ │                            │ │ │
│ │ └────────────────────────────┘ │ │
│ │                                │ │
│ └────────────────────────────────┘ │
│                                    │
└────────────────────────────────────┘
</code></pre>
<h3 id="读写日志"><a class="header" href="#读写日志">读写日志</a></h3>
<p>读写流程比较简单。</p>
<p>写流程:</p>
<ul>
<li>打开指定的 region，如果不存在则需要创建。</li>
<li>利用 client 将日志写入到 region 对应的 data topic 中。</li>
<li>更新 <code>TableMeta</code> 中的 <code>next_seq_num</code>, <code>current_high_watermark</code> 和 <code>seq_offset_mapping</code>等元数据，</li>
</ul>
<p>读流程:</p>
<ul>
<li>打开指定的 region。</li>
<li>读取 region 的所有日志数据，按表切分数据和回放等工作需要调用者实现。</li>
</ul>
<h3 id="删除日志"><a class="header" href="#删除日志">删除日志</a></h3>
<p>日志的删除可以划分为两个步骤：</p>
<ul>
<li>标记日志为可删除。</li>
<li>利用后台线程做延迟清理。</li>
</ul>
<h4 id="标记"><a class="header" href="#标记">标记</a></h4>
<ul>
<li>更新在 <code>TableMeta</code> 中的 <code>latest_mark_deleted</code> 和 <code>seq_offset_mapping</code>（需要进行维护，使得每一条目的 sequence number 大于等于更新后的 <code>latest_mark_deleted</code>）。</li>
<li>或许我们需要在删除表的时候，制作并及时同步 <code>RegionMeta</code> 的快照到 Kafka 中。</li>
</ul>
<h4 id="清理"><a class="header" href="#清理">清理</a></h4>
<p>清理逻辑如下，会在后台线程中执行：</p>
<ul>
<li>制作 <code>RegionMeta</code> 的快照。</li>
<li>根据快照判断是否需要进行清理。</li>
<li>如果需要，先同步快照到 Kafka 中，然后清理日志。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><strong>注意：此功能仍在开发中，API 将来可能会发生变化。</strong></p>
<h1 id="分区表"><a class="header" href="#分区表">分区表</a></h1>
<p>本章讨论 <code>PartitionTable</code>。</p>
<p>HoraeDB 使用的分区表语法类似于 <a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html">MySQL</a> 。</p>
<p>一般的分区表包括<code>Range Partitioning</code>、<code>List Partitoning</code>、<code>Hash Partitioning</code>和<code>Key Partititioning</code>。</p>
<p>HoraeDB 目前仅支持 Key Partitioning。</p>
<h2 id="设计"><a class="header" href="#设计">设计</a></h2>
<p>与 MySQL 类似，分区表的不同部分作为单独的表存储在不同的位置。</p>
<p>目前设计，一个分区表可以在多个 HoraeDB 节点上打开，支持同时写入和查询，可以水平扩展。</p>
<p>如下图所示，在 node0 和 node1 上打开了<code>PartitionTable</code>，在 node2 和 node3 上打开了存放实际数据的物理子表。</p>
<pre><code>                        ┌───────────────────────┐      ┌───────────────────────┐
                        │Node0                  │      │Node1                  │
                        │   ┌────────────────┐  │      │  ┌────────────────┐   │
                        │   │ PartitionTable │  │      │  │ PartitionTable │   │
                        │   └────────────────┘  │      │  └────────────────┘   │
                        │            │          │      │           │           │
                        └────────────┼──────────┘      └───────────┼───────────┘
                                     │                             │
                                     │                             │
             ┌───────────────────────┼─────────────────────────────┼───────────────────────┐
             │                       │                             │                       │
┌────────────┼───────────────────────┼─────────────┐ ┌─────────────┼───────────────────────┼────────────┐
│Node2       │                       │             │ │Node3        │                       │            │
│            ▼                       ▼             │ │             ▼                       ▼            │
│ ┌─────────────────────┐ ┌─────────────────────┐  │ │  ┌─────────────────────┐ ┌─────────────────────┐ │
│ │                     │ │                     │  │ │  │                     │ │                     │ │
│ │     SubTable_0      │ │     SubTable_1      │  │ │  │     SubTable_2      │ │     SubTable_3      │ │
│ │                     │ │                     │  │ │  │                     │ │                     │ │
│ └─────────────────────┘ └─────────────────────┘  │ │  └─────────────────────┘ └─────────────────────┘ │
│                                                  │ │                                                  │
└──────────────────────────────────────────────────┘ └──────────────────────────────────────────────────┘
</code></pre>
<h3 id="key-分区"><a class="header" href="#key-分区">Key 分区</a></h3>
<p><code>Key Partitioning</code>支持一列或多列计算，使用 HoraeDB 内置的 hash 算法进行计算。</p>
<p>使用限制：</p>
<ul>
<li>仅支持 <code>tag</code> 列作为分区键。</li>
<li>暂时不支持 <code>LINEAR KEY</code>。</li>
</ul>
<p>key 分区的建表语句如下：</p>
<pre><code class="language-sql">CREATE TABLE `demo`(
    `name`string TAG,
    `id` int TAG,
    `value` double NOT NULL,
    `t` timestamp NOT NULL,
    TIMESTAMP KEY(t)
    ) PARTITION BY KEY(name) PARTITIONS 2 ENGINE = Analytic
</code></pre>
<p>参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-key.html">MySQL key partitioning</a>。</p>
<h2 id="查询-3"><a class="header" href="#查询-3">查询</a></h2>
<p>由于分区表数据实际上是存放在不同的物理表中，所以查询时需要根据查询请求计算出实际请求的物理表。</p>
<p>首先查询会根据查询语句计算出要查询的物理表， 然后通过 HoraeDB 内部服务 <a href="https://github.com/apache/incubator-horaedb/blob/89dca646c627de3cee2133e8f3df96d89854c1a3/server/src/grpc/remote_engine_service/mod.rs">remote engine</a> 远程请求物理表所在节点获取数据（支持谓词下推）。</p>
<p>分区表的实现在 <a href="https://github.com/apache/incubator-horaedb/blob/89dca646c627de3cee2133e8f3df96d89854c1a3/analytic_engine/src/table/partition.rs">PartitionTableImpl</a> 中。</p>
<ul>
<li>第一步：解析查询 sql，根据查询参数计算出要查询的物理表。</li>
<li>第二步：查询物理表数据。</li>
<li>第三步：用拉取的数据进行计算。</li>
</ul>
<pre><code>                       │
                     1 │
                       │
                       ▼
               ┌───────────────┐
               │Node0          │
               │               │
               │               │
               └───────────────┘
                       ┬
                2      │       2
        ┌──────────────┴──────────────┐
        │              ▲              │
        │       3      │       3      │
        ▼ ─────────────┴───────────── ▼
┌───────────────┐             ┌───────────────┐
│Node1          │             │Node2          │
│               │             │               │
│               │             │               │
└───────────────┘             └───────────────┘
</code></pre>
<h3 id="key-分区-1"><a class="header" href="#key-分区-1">Key 分区</a></h3>
<ul>
<li>带有 <code>and</code>, <code>or</code>, <code>in</code>, <code>=</code> 的过滤器将选择特定的子表。</li>
<li>支持模糊匹配过滤器，如 <code>&lt;</code>, <code>&gt;</code>，但可能性能较差，因为它会扫描所有物理表。</li>
</ul>
<p><code>Key partitioning</code> 规则实现在 <a href="https://github.com/apache/incubator-horaedb/blob/89dca646c627de3cee2133e8f3df96d89854c1a3/table_engine/src/partition/rule/key.rs">KeyRule</a>。</p>
<h2 id="写入-2"><a class="header" href="#写入-2">写入</a></h2>
<p>写入过程与查询过程类似。</p>
<p>首先根据分区规则，将写入请求拆分到不同的物理表中，然后通过 <code>remote engine</code> 服务发送到不同的物理节点进行实际的数据写入。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        <footer>
          <div>
            <p> Apache HoraeDB is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF. </p>
            <p>
              Copyright © 2024 The Apache Software Foundation, Licensed under the Apache License, Version 2.0. <br/>
              Apache HoraeDB, HoraeDB, Apache, and its feather logo, and the feather logo are either registered trademarks or trademarks of the Apache Software Foundation in the United States and/or other countries.
            </p>
          </div>
        </footer>
        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="sidebar.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

        <script type="text/javascript">
         let langs = [
                                'cn',
                                'en'
                            ];

        (function langs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('click', function (e) {
               let langs = [
                        'cn',
                        'en'
                    ];
                var lang = e.target.id || e.target.parentElement.id;
                var path_list=[];
                window.location.pathname.split('/').map((s, idx) => {
                    if (idx == 1){
                        if(!langs.includes(s)){
                            path_list.push(lang);
                            path_list.push(s);
                        }else{
                            path_list.push(lang);
                        }
                    }else{
                        path_list.push(s);
                    }
                });
                console.log("path:");
                window.location.pathname = path_list.join('/');
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

        })();
        </script>

    </body>
</html>
